#!/bin/bash
# ############################################################################################
# File: ........: functions
# Language .....: bash
# Author .......: Sacha Dubois, VMware
# Description ..: Tanzu Demo Hub - Cluster Installation
# ############################################################################################

waitCmd() {
  read
}

prtHead() {
  if [ "${tocindex}" == "" ]; then tocindex=1; else let tocindex=tocindex+1; fi
  printf "%2d.) %s\n" $tocindex "$1"
}

prtText() {
  if [ "${tocindex}" == "" ]; then tocindex=1; else let tocindex=tocindex+1; fi
  printf "%2s   %s\n" "" "$1"
}

execCmd() {
  bold=$(tput bold)
  normal=$(tput sgr0)

  echo -e "     => ${bold}$1${normal}\c"; read x
  echo "     -----------------------------------------------------------------------------------------------------------"
  eval "$1" 2>&1 | sed -e '/^$/d' -e 's/^/     /g'
  #$1 | sed -e '/^$/d' -e 's/^/     /g'
  echo "     -----------------------------------------------------------------------------------------------------------"
  echo ""
  if [ $? -ne 0 ]; then exit 1; fi
}

tmcCheckLogin() {
  tmc cluster list >/dev/null 2>&1

  if [ $? -ne 0 ]; then 
    echo "ERROR: Currently not logged in in TMC, please login: tmc login"
    exit 1
  fi
}

messageTitle() {
  _msg="$*"
  _dat=$(date "+%Y%m%d-%H:%M:%S")

  if [ "${PCF_DEPLOYMENT_DEBUG}" == "true" -o "${DEBUG}" == "1" ]; then
    echo "[${_dat}] ${_msg}"
  else
    echo "${_msg}"
  fi
}

messagePrint() {
  _msg="$1"
  _stt="$2"
  _cnt=$(echo "${_msg}" | wc -c | sed 's/ //g')
  _dat=$(date "+%Y%m%d-%H:%M:%S")

  _str=""
  while [ $_cnt -lt 58 ]; do
    _str="${_str}."
    let _cnt=_cnt+1
  done

  # --- INIZIALIZE VALUES IF EMPTY --- ---
  [ "$DEBUG" == "" ] && DEBUG=0

  if [ "${PCF_DEPLOYMENT_DEBUG}" == "true" -o "${DEBUG}" == "1" ]; then
    echo "[${_dat}] ${_msg} ${_str}: ${_stt}"
  else
    echo "${_msg} ${_str}: ${_stt}"
  fi
}

sshEnvironment() {
  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "vSphere" ]; then
    JUMP_HOST="${TDH_TKGMC_VCENTER_JUMPHOST}"

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_PRIVATE_KEY=~/.tanzu-demo-hub/KeyPair-Azure.pem
    SSH_PRIVATE_KEY=$VSPHERE_SSH_PRIVATE_KEY_FILE
    SSH_HOST=$JUMP_HOST
    SSH_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=240 -o ClientAliveInterval=240"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=240"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i ${SSH_PRIVATE_KEY} ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -i ${SSH_PRIVATE_KEY} -r $SCP_OPTIONS"
    SSH_DISPLAY="ssh $SSH_OPTIONS -i ${SSH_PRIVATE_KEY} ${SSH_USER}@${SSH_HOST}"

  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" -o "${TDH_TKGMC_INFRASTRUCTURE}" == "Azure" ]; then
    JUMP_HOST="jump-${TDH_TKGMC_ENVNAME}.${AWS_HOSTED_DNS_DOMAIN}"

    pip=""
    while [ "$pip" == "" -o "$pip" == "null" ]; do
      pip=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$TDH_TKGMC_ENVNAME')]" | \
            jq -r '.[].ipAddress')
      sleep 10
    done

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_PRIVATE_KEY=~/.tanzu-demo-hub/KeyPair-Azure.pem
    SSH_HOST=$pip
    SSH_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=240 -o ClientAliveInterval=240"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=240"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i ${SSH_PRIVATE_KEY} ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -i ${SSH_PRIVATE_KEY} -r $SCP_OPTIONS"
    SSH_DISPLAY="ssh $SSH_OPTIONS -i ${SSH_PRIVATE_KEY} ${SSH_USER}@${SSH_HOST}"
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    SSH_HOST=$(aws ec2 --region=$AWS_REGION describe-instances \
                     --filters Name=tag:sigs.k8s.io/cluster-api-provider-aws/role,Values="bastion" | \
             jq -r '.Reservations[].Instances[].PublicDnsName')

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SSH_DISPLAY="-o StrictHostKeyChecking=no"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i $SSH_KEY_FILE ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS -i $SSH_KEY_FILE"
    SSH_DISPLAY="ssh -i $SSH_KEY_FILE ${SSH_USER}@${SSH_HOST}"
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    INSTANCE_NAME="$(echo $JUMP_HOST | awk -F'.' '{ print $1 }')"
    #ZONE=$(gcloud compute zones list | grep " $GCP_REGION " | head -1 | awk '{ print $1 }')
    ZONE=$(gcloud compute instances list --filter="name=( '$INSTANCE_NAME')" | egrep "^$INSTANCE_NAME" | awk '{ print $2 }')

    prj=$(gcloud projects list | sed '1d' | awk '{ print $1 }')
    prj=${GCP_PROJECT}

    SSH_USER=$(whoami)
    SSH_HOME=/home/$(whoami)
    SSH_HOST="${INSTANCE_NAME}.${ZONE}.${prj}"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
    SSH_DISPLAY="ssh ${SSH_USER}@${SSH_HOST}"
  fi

  echo "--------------------------------- JUMP SERVER ACCESS ------------------------------------------------------"
  echo "$SSH_DISPLAY"
  echo "-----------------------------------------------------------------------------------------------------------"
}

checkCloudCLI() {
  if [ "${TDH_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    # --- CHECK FOR AWS CLI ---
    GCLOUD=$(which gcloud)
    if [ "${GCLOUD}" != "" ]; then
      $GCLOUD --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        GCLOUD_VERSION=$($GCLOUD --version 2>/dev/null | grep "Google Cloud SDK" | awk '{ print $NF}')
        GCP_CLI_ENABLED=1
        messagePrint "checking for gcloud CLI utility" "installed - ${GCLOUD_VERSION}"
      else
        echo ""
        echo "ERROR: The gcloud utility does not seam to be correct"
        echo "       please install gcloud from https://cloud.google.com/sdk/install"; exit 1
      fi
    else
      messagePrint "checking for gcloud CLI utility" "not installed"
      echo ""
      echo "ERROR: gcloud utility is not installed. please install terraform from"
      echo "       https://cloud.google.com/sdk/install"; exit 1
    fi

    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility (needed for AWS Route53)" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    # --- CHECK FOR AWS CLI ---
    AZCLI=$(which az)
    if [ "${AZCLI}" != "" ]; then
      $AZCLI -v >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AZ_VERSION=$($AZCLI -v 2>/dev/null | egrep "^azure-cli" | awk '{ print $2 }'); ret=$?
        AZURE_CLI_ENABLED=1
        messagePrint "checking for Azure CLI utility (az)" "installed - ${AZ_VERSION}"
      else
        echo ""
        echo "ERROR: the $cloud CLI $(which az) does not seam to be correct"
        echo "       please install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest"; exit 1
      fi
    else
      messagePrint "checking for $cloud CLI utility" "no installed"
    fi
    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility (needed for AWS Route53)" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi
}

checkCloudAccess() {
  missing_variables=0

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "vSphere" ]; then
    if [ "${VSPHERE_ADMIN}" == "" -o "${VSPHERE_PASSWORD}" == "" -o "${VSPHERE_SERVER}" == "" -o \
         "${VSPHERE_DATACENTER}" == "" -o "${VSPHERE_DATASTORE}" == "" -o "${VSPHERE_CLUSTER}" == "" -o \
         "${VSPHERE_SSH_PRIVATE_KEY_FILE}" == "" -o "${VSPHERE_SSH_PUBLIC_KEY_FILE}" == "" -o \
         "${VSPHERE_CONTROLPLANE_IP}" == "" -o \
         "${VSPHERE_MANAGEMENT_NETWORK}" == "" -o "${VSPHERE_WAN_NETWORK}" == "" -o "${VSPHERE_CLUSTER}" == "" ]; then
      missing_variables=1
      echo ""
      echo "  4MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${VSPHERE_SERVER}" == "" ]; then
        echo "  VSPHERE_SERVER                   (required) vSphere Server Name"
      fi

      if [ "${VSPHERE_CONTROLPLANE_IP}" == "" ]; then
        echo "  VSPHERE_CONTROLPLANE_IP          (required) TKG Controlplance IP"
      fi

      if [ "${VSPHERE_ADMIN}" == "" ]; then
        echo "  VSPHERE_ADMIN                    (required) vSphere Amdinistrator"
      fi

      if [ "${VSPHERE_PASSWORD}" == "" ]; then
        echo "  VSPHERE_PASSWORD                 (required) vSphere Admin Password"
      fi

      if [ "${VSPHERE_DATACENTER}" == "" ]; then
        echo "  VSPHERE_DATACENTER               (required) vSphere Datacenter"
      fi

      if [ "${VSPHERE_DATASTORE}" == "" ]; then
        echo "  VSPHERE_DATASTORE                (required) vSphere Datastore"
      fi

      if [ "${VSPHERE_CLUSTER}" == "" ]; then
        echo "  VSPHERE_CLUSTER                  (required) vSphere Cluster"
      fi

      if [ "${VSPHERE_MANAGEMENT_NETWORK}" == "" ]; then
        echo "  VSPHERE_MANAGEMENT_NETWORK       (required) vSphere Management Network"
      fi

      if [ "${VSPHERE_WAN_NETWORK}" == "" ]; then
        echo "  VSPHERE_WAN_NETWORK              (required) vSphere WAN Network"
      fi

      if [ "${VSPHERE_SSH_PRIVATE_KEY_FILE}" == "" ]; then
        echo "  VSPHERE_SSH_PRIVATE_KEY_FILE     (required) SSH Private Key File"
      fi
    
      if [ "${VSPHERE_SSH_PUBLIC_KEY_FILE}" == "" ]; then
        echo "  VSPHERE_SSH_PUBLIC_KEY_FILE      (required) SSH Public Key File"
      fi
    else
      echo "vSphere Access Credentials"
      messagePrint " - vSphere Server Name"                "$VSPHERE_SERVER"
      messagePrint " - vSphere Admin User"                 "$VSPHERE_ADMIN"
      messagePrint " - vSphere Admin Password"             $(maskPassword "$VSPHERE_PASSWORD")
      messagePrint " - vSphere Datacenter"                 "$VSPHERE_DATACENTER"
      messagePrint " - vSphere Datastore"                  "$VSPHERE_DATASTORE"
      messagePrint " - vSphere Cluster NAme"               "$VSPHERE_CLUSTER"
      messagePrint " - vSphere Management Network"         "$VSPHERE_MANAGEMENT_NETWORK"
      messagePrint " - vSphere WAN Network"                "$VSPHERE_WAN_NETWORK"
      messagePrint " - SSH Private Key"                    "$VSPHERE_SSH_PRIVATE_KEY_FILE"
      messagePrint " - SSH Public Key"                     "$VSPHERE_SSH_PUBLIC_KEY_FILE"
    fi

    # --- VERIFY OVA-IMAGES / OVFTOOL BUNDLE ---
    found=1; file_list=""
    for n in $TDH_TKGMC_TKG_IMAGES; do
      if [ ! -f $n ]; then found=0; file_list="$file_list $n"; fi
    done

    if [ $found -eq 0 ]; then 
      txt="ERROR: Missing OVA Images for TKG:"
      for n in $file_list; do 
        echo "$txt $n"; txt="                                  "
      done

      echo "Please download them from the VMware Download page:"
      echo "=> https://my.vmware.com/group/vmware/downloads/details?downloadGroup=TKG-121&productId=988"
      exit
    fi

    if [ ! -f $TDH_TKGMC_OVFTOOL_BUNDLE ]; then 
      echo "ERROR: Missing OVFTOOL Bundle, please download it from the VMware Download page:"
      echo "=> https://my.vmware.com/group/vmware/downloads/details?downloadGroup=OVFTOOL441&productId=734"
    fi
  fi

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "GCP" ]; then
    #if [ "${GCP_SERVICE_ACCOUNT}" == "" -o "${GCP_REGION}" == "" -o "${GCP_PROJECT}" == "" ]; then
    if [ "${GCP_REGION}" == "" -o "${GCP_PROJECT}" == "" ]; then
      missing_variables=1
      echo ""
      echo "  4MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      #if [ "${GCP_SERVICE_ACCOUNT}" == "" ]; then
      #  echo "  GCP_SERVICE_ACCOUNT           (required) GCP Service Account"
      #fi

      if [ "${GCP_PROJECT}" == "" ]; then
        echo "  GCP_PROJECT                   (required) GCP Project"
        echo "                                  => gcloud projects list | sed '1d' | awk '{ print \$1 }'"
      fi

      if [ "${GCP_REGION}" == "" ]; then
        echo "  GCP_REGION                    (required) Choose the GCP Region where your installation should run"
        echo "                                  => gcloud compute zones list | sed '1d' | awk '{ print $2 }' | sort -u"
        echo "                                     europe-west1, us-east1, europe-west4  etc."
      fi
    else
      echo "GCP Access Credentials"
      #messagePrint " - GCP Service Account"          "$GCP_SERVICE_ACCOUNT"
      messagePrint " - GCP Project"                  "$GCP_PROJECT"
      messagePrint " - GCP Region"                   "$GCP_REGION"
    fi
  fi

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "AWS" ]; then
    if [ "${AWS_ACCESS_KEY}" == "" -o "${AWS_SECRET_KEY}" == "" -o \
         "${AWS_REGION}" == "" ]; then

      missing_variables=1
      echo ""
      echo "  5MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${AWS_ACCESS_KEY}" == "" ]; then
        echo "  AWS_ACCESS_KEY                  (required) AWS Acess Key"
      fi

      if [ "${AWS_SECRET_KEY}" == "" ]; then
        echo "  AWS_SECRET_KEY                  (required) AWS Secret Key"
      fi

      if [ "${AWS_REGION}" == "" ]; then
        echo "  AWS_REGION                    (required) Choose the AWS Region where your installation should run"
        echo "                                  => aws ec2 --region=eu-west-3 describe-regions --output text | awk '{ print $NF }'"
        echo "                                     eu-north-1, eu-west-3, eu-central-1 etc."
      fi
    else
      messageTitle "Azure Access Credentials"
      messagePrint " - AWS AccwssKey"                $(maskPassword "$AWS_ACCESS_KEY")
      messagePrint " - AWS SecretKey"                $(maskPassword "$AWS_SECRET_KEY")
      messagePrint " - AWS Region"                   "$AWS_REGION"
    fi
  fi

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "Azure" ]; then
    if [ "${AZURE_SUBSCRIPTION_ID}" == "" -o "${AZURE_TENANT_ID}" == "" -o \
         "${AZURE_CLIENT_ID}" == "" -o "${AZURE_CLIENT_SECRET}" == "" -o "${AZURE_LOCATION}" == "" ]; then

      missing_variables=1
      echo ""
      echo "  1MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${AZURE_SUBSCRIPTION_ID}" == "" ]; then
        echo "  AZURE_SUBSCRIPTION_ID           (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi

      if [ "${AZURE_TENANT_ID}" == "" ]; then
        echo "  AZURE_TENANT_ID                 (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi

      if [ "${AZURE_CLIENT_ID}" == "" ]; then
        echo "  AZURE_CLIENT_ID                 (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
        echo "                                  => az ad sp create-for-rbac --name \"TanzuDemoHub\" ## appId"
      fi

      if [ "${AZURE_CLIENT_SECRET}" == "" ]; then
        echo "  AZURE_CLIENT_SECRET             (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
        echo "                                  => az ad sp create-for-rbac --name \"TanzuDemoHub\" ## password"
      fi

      if [ "${AZURE_LOCATION}" == "" ]; then
        echo "  AZURE_LOCATION                    (required) Choose the Azure Region where your installation should run"
        echo "                                  => az account list-locations -o table | awk '{ print $NF }'"
        echo "                                     westeurope, northeurope, switzerlandnorth etc."
      fi
    else
      messageTitle "Azure Access Credentials"
      messagePrint " - Azure SubscriptionId"         $(maskPassword "$AZURE_SUBSCRIPTION_ID")
      messagePrint " - Azure TennantId"              $(maskPassword "$AZURE_TENANT_ID")
      messagePrint " - Azure ClientId"               $(maskPassword "$AZURE_CLIENT_ID")
      messagePrint " - Azure Client Secret"          $(maskPassword "$AZURE_CLIENT_SECRET")
      messagePrint " - Azure Region"                 "$AZURE_LOCATION"
    fi
  fi

  if [ ${missing_variables} -eq 1 ]; then
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  IMPORTANT: Please set the missing environment variables either in your shell or in the pcfconfig"
    echo "             configuration file ~/.tanzu-demo-hub.cfg and set all variables with the 'export' notation"
    echo "             ie. => export AZURE_PKS_TLS_CERTIFICATE=/home/demouser/certs/cert.pem"
    echo "  --------------------------------------------------------------------------------------------------------------"
    exit 1
  fi
}

checkTDHAccess() {
  missing_variables=0

  if [ "${PCF_PIVNET_TOKEN}" == "" -o "${AWS_HOSTED_DNS_DOMAIN}" == "" ]; then
    missing_variables=1
    echo ""
    echo "  2MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
    echo "  --------------------------------------------------------------------------------------------------------------"

    if [ "${PCF_PIVNET_TOKEN}" == "" ]; then
      echo "  PCF_PIVNET_TOKEN                (required) PIVNET Access Token to download software. Get a UAA API TOKEN from"
      echo "                                  => https://network.pivotal.io/users/dashboard/edit-profile"
    fi

    if [ "${AWS_ACCESS_KEY}" == "" ]; then
      echo "  AWS_ACCESS_KEY                  (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    if [ "${AWS_SECRET_KEY}" == "" ]; then
      echo "  AWS_SECRET_KEY                  (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    if [ "${AWS_HOSTED_DNS_DOMAIN}" == "" ]; then
      echo "  AWS_HOSTED_DNS_DOMAIN           (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    #if [ "${AWS_HOSTED_ZONE_ID}" == "" ]; then
    #  echo "  AWS_HOSTED_ZONE_ID              (required) An AWS Route 53 Token is required to add/update DNS records"
    #  echo "                                  => https://console.aws.amazon.com/route53 -> hosted Zones -> Zone ID"
    #fi
  else
    messageTitle "Supporting services access (Pivotal Network, AWS Route53)"
    messagePrint " - Pivotal Network Token"           "$PCF_PIVNET_TOKEN"
    messagePrint " - AWS Route53 Hosted DNS Domain"   "$AWS_HOSTED_DNS_DOMAIN"

    # --- VERIFY PIVNET ACCESS ---
    pivnetAPI $PCF_PIVNET_TOKEN
    if [ $? -ne 0 ]; then
      write_line
      echo "ERROR: Pivnet Token: $PCF_PIVNET_TOKEN does not seam to be valit. Please greate a new one by"
      echo "       login to http://network.pivotal.io => Your login Name => Edit Profile => UAA API TOKEN"
      exit 1
    fi

    # --- CHECK IF AWS CLI IS CONFIGURED ---
    if [ ! -d ~/.aws -o -d ~/.aws/credentials ]; then
      echo "ERROR: AWS CLI is not configured yet, please run aws configure"
      echo "       => aws configure"
      exit 1
    fi

    export AWS_HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?starts_with(to_string(Name), '${AWS_HOSTED_DNS_DOMAIN}.')]" | \
                        jq -r '.[].Id' | awk -F '/' '{ print $NF }')
    if [ $? -ne 0 -o "${AWS_HOSTED_ZONE_ID}" == "" ]; then
      echo "ERROR: failed to get domain information for ($AWS_HOSTED_DNS_DOMAIN)"
      echo "       => aws route53 list-hosted-zones --query \"HostedZones[?starts_with(to_string(Name), '${AWS_HOSTED_DNS_DOMAIN}.')]\""
      exit 1
    else
      messagePrint " - AWS Route53 ZoneID"              "$AWS_HOSTED_ZONE_ID"
    fi

    pslug="pivotal-container-service"; pver="1.5"
    pslug="elastic-runtime"; pver="2.6.6"
    pslug="elastic-runtime"; pver="467928"
  fi

  if [ ${missing_variables} -eq 1 ]; then
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  IMPORTANT: Please set the missing environment variables either in your shell or in the pcfconfig"
    echo "             configuration file ~/.pcfconfig and set all variables with the 'export' notation"
    echo "             ie. => export AZURE_PKS_TLS_CERTIFICATE=/home/demouser/certs/cert.pem"
    echo "  --------------------------------------------------------------------------------------------------------------"
    exit 1
  fi

} 

pivnetAPI() {
  REFRESH_TOKEN="$1"
  token=$(curl -X POST https://network.pivotal.io/api/v2/authentication/access_tokens \
               -d "{\"refresh_token\":\"$REFRESH_TOKEN\"}" 2>/dev/null | jq -r '.access_token')
  if [ "${token}" == "" -o "${token}" == "null" ]; then return 1; fi

  # --- LOGIN INTO PIVNET ---
  curl -X GET https://network.pivotal.io/api/v2/authentication -H "Authorization: Bearer $token"

  # --- PIVNET ACCESS TEST ---
  if [ "${2}" == "" ]; then
    return 0
  fi

  curl -H "Authorization: Bearer $token" -X $2 https://network.pivotal.io/api/v2/$3

  return 0
}

write_line() {
  messageTitle "----------------------------------------------------------------------------------------------------------------"
}

createENVfile() {
  dep="$1"
  envFile="$2"

  rm -f $env
  . ${TANZU_DEMO_HUB}/deployments/$dep

  cat ${TANZU_DEMO_HUB}/deployments/$dep | sed -e '/^$/d' -e '/^#/d' -e 's/#.*$//g' > $envFile

  echo "PCF_DEPLOYMENT_DEBUG=$PCF_DEPLOYMENT_DEBUG"                              >> $envFile
  echo "AWS_HOSTED_ZONE_ID=$AWS_HOSTED_ZONE_ID"                                  >> $envFile
  echo "AWS_HOSTED_DNS_DOMAIN=$AWS_HOSTED_DNS_DOMAIN"                            >> $envFile
  echo "PCF_PIVNET_TOKEN=$PCF_PIVNET_TOKEN"                                      >> $envFile

  echo "PCF_TILE_PKS_ADMIN_USER=$PCF_TILE_PKS_ADMIN_USER"                        >> $envFile
  echo "PCF_TILE_PKS_ADMIN_PASS=$PCF_TILE_PKS_ADMIN_PASS"                        >> $envFile
  echo "PCF_TILE_PKS_ADMIN_EMAIL=$PCF_TILE_PKS_ADMIN_EMAIL"                      >> $envFile
  echo "PCF_TILE_PAS_ADMIN_USER=$PCF_TILE_PAS_ADMIN_USER"                        >> $envFile
  echo "PCF_TILE_PAS_ADMIN_PASS=$PCF_TILE_PAS_ADMIN_PASS"                        >> $envFile
  echo "PCF_TILE_PAS_ADMIN_EMAIL=$PCF_TILE_PAS_ADMIN_EMAIL"                      >> $envFile

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    #echo "GCP_SERVICE_ACCOUNT=/tmp/$(basename $GCP_SERVICE_ACCOUNT)"             >> $envFile
    echo "GCP_REGION=\"$GCP_REGION\""                                            >> $envFile
    echo "GCP_PROJECT=\"$GCP_PROJECT\""                                          >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then
      if [ "${GCP_PKS_TLS_CERTIFICATE}" != "" -a "${GCP_PKS_TLS_FULLCHAIN}" != "" -a \
           "${GCP_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$GCP_PKS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$GCP_PKS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$GCP_PKS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${GCP_PAS_TLS_CERTIFICATE}" != "" -a "${GCP_PAS_TLS_FULLCHAIN}" != "" -a \
           "${GCP_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$GCP_PAS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$GCP_PAS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$GCP_PAS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_HARBOR_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_HARBOR_ADMIN_PASS=\"$PCF_TILE_HARBOR_ADMIN_PASS\"" >> $envFile
    fi
    if [ "${PCF_TILE_PBS_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_PBS_DEPLOY=\"$PCF_TILE_PBS_DEPLOY\""               >> $envFile
      echo "PCF_TILE_PBS_NAME=\"$PCF_TILE_PBS_NAME\""                   >> $envFile
      echo "PCF_TILE_PBS_SLUG=\"$PCF_TILE_PBS_SLUG\""                   >> $envFile
      echo "PCF_TILE_PBS_VERSION=\"$PCF_TILE_PBS_VERSION\""             >> $envFile
      echo "PCF_TILE_PBS_ADMIN_USER=\"$PCF_TILE_PBS_ADMIN_USER\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_PASS=\"$PCF_TILE_PBS_ADMIN_PASS\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_EMAIL=\"$PCF_TILE_PBS_ADMIN_EMAIL\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_REPO=\"$PCF_TILE_PBS_DOCKER_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_USER=\"$PCF_TILE_PBS_DOCKER_USER\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_PASS=\"$PCF_TILE_PBS_DOCKER_PASS\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_REPO=\"$PCF_TILE_PBS_GITHUB_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_USER=\"$PCF_TILE_PBS_GITHUB_USER\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_PASS=\"$PCF_TILE_PBS_GITHUB_PASS\""     >> $envFile
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    echo "AWS_ACCESS_KEY=\"$AWS_ACCESS_KEY\""                                    >> $envFile
    echo "AWS_SECRET_KEY=\"$AWS_SECRET_KEY\""                                    >> $envFile
    echo "AWS_REGION=\"$AWS_REGION\""                                            >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then
      if [ "${AWS_PKS_TLS_CERTIFICATE}" != "" -a "${AWS_PKS_TLS_FULLCHAIN}" != "" -a \
           "${AWS_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AWS_PKS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$AWS_PKS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AWS_PKS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${AWS_PAS_TLS_CERTIFICATE}" != "" -a "${AWS_PAS_TLS_FULLCHAIN}" -o \
           "${AWS_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AWS_PAS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$AWS_PAS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AWS_PAS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_HARBOR_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_HARBOR_ADMIN_PASS=\"$PCF_TILE_HARBOR_ADMIN_PASS\"" >> $envFile
    fi

    if [ "${PCF_TILE_PBS_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_PBS_DEPLOY=\"$PCF_TILE_PBS_DEPLOY\""               >> $envFile
      echo "PCF_TILE_PBS_NAME=\"$PCF_TILE_PBS_NAME\""                   >> $envFile
      echo "PCF_TILE_PBS_SLUG=\"$PCF_TILE_PBS_SLUG\""                   >> $envFile
      echo "PCF_TILE_PBS_VERSION=\"$PCF_TILE_PBS_VERSION\""             >> $envFile
      echo "PCF_TILE_PBS_ADMIN_USER=\"$PCF_TILE_PBS_ADMIN_USER\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_PASS=\"$PCF_TILE_PBS_ADMIN_PASS\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_EMAIL=\"$PCF_TILE_PBS_ADMIN_EMAIL\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_REPO=\"$PCF_TILE_PBS_DOCKER_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_USER=\"$PCF_TILE_PBS_DOCKER_USER\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_PASS=\"$PCF_TILE_PBS_DOCKER_PASS\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_REPO=\"$PCF_TILE_PBS_GITHUB_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_USER=\"$PCF_TILE_PBS_GITHUB_USER\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_PASS=\"$PCF_TILE_PBS_GITHUB_PASS\""     >> $envFile
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    echo "AZURE_SUBSCRIPTION_ID=\"$AZURE_SUBSCRIPTION_ID\""                      >> $envFile
    echo "AZURE_TENANT_ID=\"$AZURE_TENANT_ID\""                                  >> $envFile
    echo "AZURE_CLIENT_ID=\"$AZURE_CLIENT_ID\""                                  >> $envFile
    echo "AZURE_CLIENT_SECRET=\"$AZURE_CLIENT_SECRET\""                          >> $envFile
    echo "AZURE_LOCATION=\"$AZURE_LOCATION\""                                    >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then
      if [ "${AZURE_PKS_TLS_CERTIFICATE}" != "" -a "${AZURE_PKS_TLS_FULLCHAIN}" -o \
           "${AZURE_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AZURE_PKS_TLS_CERTIFICATE\""           >> $envFile
        echo "TLS_FULLCHAIN=\"$AZURE_PKS_TLS_FULLCHAIN\""               >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AZURE_PKS_TLS_PRIVATE_KEY\""           >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${AZURE_PAS_TLS_CERTIFICATE}" != "" -a "${AZURE_PAS_TLS_FULLCHAIN}" -o \
           "${AZURE_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AZURE_PAS_TLS_CERTIFICATE\""           >> $envFile
        echo "TLS_FULLCHAIN=\"$AZURE_PAS_TLS_FULLCHAIN\""               >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AZURE_PAS_TLS_PRIVATE_KEY\""           >> $envFile
      fi
    fi

    if [ "${PCF_TILE_HARBOR_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_HARBOR_ADMIN_PASS=\"$PCF_TILE_HARBOR_ADMIN_PASS\"" >> $envFile
    fi

    if [ "${PCF_TILE_PBS_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_PBS_DEPLOY=\"$PCF_TILE_PBS_DEPLOY\""               >> $envFile
      echo "PCF_TILE_PBS_NAME=\"$PCF_TILE_PBS_NAME\""                   >> $envFile
      echo "PCF_TILE_PBS_SLUG=\"$PCF_TILE_PBS_SLUG\""                   >> $envFile
      echo "PCF_TILE_PBS_VERSION=\"$PCF_TILE_PBS_VERSION\""             >> $envFile
      echo "PCF_TILE_PBS_ADMIN_USER=\"$PCF_TILE_PBS_ADMIN_USER\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_PASS=\"$PCF_TILE_PBS_ADMIN_PASS\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_EMAIL=\"$PCF_TILE_PBS_ADMIN_EMAIL\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_REPO=\"$PCF_TILE_PBS_DOCKER_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_USER=\"$PCF_TILE_PBS_DOCKER_USER\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_PASS=\"$PCF_TILE_PBS_DOCKER_PASS\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_REPO=\"$PCF_TILE_PBS_GITHUB_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_USER=\"$PCF_TILE_PBS_GITHUB_USER\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_PASS=\"$PCF_TILE_PBS_GITHUB_PASS\""     >> $envFile
    fi
  fi
}

configureJumpHost() {
  messagePrint "Configure Jump Server" "$SSH_HOST"

  # --- WAIT UNTIL SSH DEAMON IS READY NO JUMPHOST ----
  ret=1
  while [ $ret -ne 0 ]; do
    $SSH_COMMAND -n id > /dev/null 2>&1; ret=$?
    [ $ret -ne 0 ] && sleep 10
  done

  GITTDH="https://github.com/pivotal-sadubois/tanzu-demo-hub.git"
  TDHHOME="${SSH_HOME}/tanzu-demo-hub"

  messagePrint " - Verify SSH Access" "success"

  $SSH_COMMAND -n "[ ! -d /home/ubuntu/tanzu-demo-hub ] && git clone $GITTDH > /dev/null 2>&1"
  $SSH_COMMAND -n "[ -d /home/ubuntu/tanzu-demo-hub ] && cd $SSH_HOME/tanzu-demo-hub; git pull > /dev/null 2>&1"

  # --- HOSTNAME ---
#  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" -o "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
#    $SSH_COMMAND -n "sudo hostname $JUMP_HOST > /dev/null 2>&1"
#  fi

  # --- TEST FOR RUNNING REMOTE SCRIPT ---
  stt=$($SSH_COMMAND -n "[ -f /tmp/tanzu-demo-hub.pid ] && pgrep -F /tmp/tanzu-demo-hub.pid")
  stt=$($SSH_COMMAND -n "[ -f /jump_software_installed ] && echo true")
  if [ "${stt}" == "" ]; then
    messagePrint " - Install CLI Utilities"   "aws,az,gcp,bosh,pivnet,cf,om,jq"
    $SSH_COMMAND -n "[ -d $SSH_HOME/tanzu-demo-hub ] && chmod a+x ${TDHHOME}/scripts/InstallUtilities.sh && \
        sudo ${TDHHOME}/scripts/InstallUtilities.sh $PCF_PIVNET_TOKEN > /dev/null 2>&1"

    # --- COPY THE AWS DIRECTORY ---
    $SCP_COMMAND -r ~/.aws ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
    $SCP_COMMAND -r ~/.azure ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
    $SCP_COMMAND -r ~/.tanzu-demo-hub ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
    $SCP_COMMAND -r ~/.tanzu-demo-hub.cfg ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
  fi

  # --- COPY SOFTWARE ---
  stt=$($SSH_COMMAND -n "[ -d /home/ubuntu/tanzu-demo-hub/software ] && echo true")
  if [ "${stt}" == "" ]; then
    # --- COPY THE AWS DIRECTORY ---
    $SCP_COMMAND -r ${TDHPATH}/software ${SSH_USER}@${SSH_HOST}:${SSH_HOME}/tanzu-demo-hub/ > /dev/null 2>&1
  fi

  # --- INSTALL TKG UTILITES ---
  stt=$($SSH_COMMAND -n "[ -f /tkg_software_installed ] && echo true")
  if [ "${stt}" == "" ]; then
    messagePrint " - Install TKG Utilities"   "tkg, ytt, kapp, kbld, kubectl, kind"
    $SSH_COMMAND -n "[ -d $SSH_HOME/tanzu-demo-hub ] && chmod a+x ${TDHHOME}/scripts/InstallTKGutilities.sh && \
        sudo ${TDHHOME}/scripts/InstallTKGutilities.sh \"$SSH_HOME/tanzu-demo-hub\" > /dev/null 2>&1"
    #$SSH_COMMAND -n "[ -d $SSH_HOME/tanzu-demo-hub ] && chmod a+x ${TDHHOME}/scripts/InstallTKGutilities.sh && \
    #    sudo ${TDHHOME}/scripts/InstallTKGutilities.sh \"$SSH_HOME/tanzu-demo-hub\"" 

    # --- WAIT UNTIL SSH DEAMON IS READY NO JUMPHOST ----
    ret=1
    while [ $ret -ne 0 ]; do
      $SSH_COMMAND -n id > /dev/null 2>&1; ret=$?
      [ $ret -ne 0 ] && sleep 10
    done
  fi
}

route53createHostedZone() {
  zone=$1

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${zone} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$zone.\")).Id")
  if [ "${ZONE_ID}" != "" ]; then
    route53deleteHostedZone $ZONE_ID
  fi

  aws route53 create-hosted-zone --name $zone --caller-reference "$(date)" \
       --hosted-zone-config Comment="Managed by pcfconfig" > /dev/null 2>&1
  if [ $? -ne 0 ]; then
      echo "ERROR: failed to create AWS Route53 zone $ZONE_ID"
      echo "       => aws route53 create-hosted-zone --name $zone --caller-reference \"$(date)\" \\"
      echo "          --hosted-zone-config Comment=\"command-line version\""
      exit 1
  fi

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${zone} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$zone.\")).Id")
  NAME_SERVERS=$(aws route53 get-hosted-zone --id $ZONE_ID | jq -r '.DelegationSet.NameServers[]')

  # --- CREATE ZONE ---
  route53setNSrecord $zone "$AWS_HOSTED_DNS_DOMAIN" "$NAME_SERVERS"
}

route53setNSrecord () {
  hnm=$1; dom=$2; dns="$3"

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$dom.\")).Id")
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
  if [ "${ZONE_ID}" == "" ]; then
    echo "ERROR: ZoneID for domain $dom can not be optained, please veriofy manually"
    echo "       aws route53 list-hosted-zones-by-name --dns-name ${dom}"
    exit 1
  fi

  DNS1=$(echo $dns | awk '{ print $1 }')
  DNS2=$(echo $dns | awk '{ print $2 }')
  DNS3=$(echo $dns | awk '{ print $3 }')
  DNS4=$(echo $dns | awk '{ print $4 }')

  TMPROUTE53=/tmp/$$_tmp_route53.json
  echo "{"                                                   >  $TMPROUTE53
  echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
  echo "  \"Changes\": [{"                                   >> $TMPROUTE53
  echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
  echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
  echo "    \"Name\": \"${hnm}\","                           >> $TMPROUTE53
  echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
  echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
  echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
  echo "    ]"                                               >> $TMPROUTE53
  echo "}}]"                                                 >> $TMPROUTE53
  echo "}"                                                   >> $TMPROUTE53

  aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
      --change-batch file://${TMPROUTE53} > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to set DNS for $hnm"
    echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
    echo "              --change-batch file://${TMPROUTE53}"
    cat /tmp/$$_zone_record
    exit 1
  fi
}

route53deleteHostedZone() {
  ZONE_ID=$1
  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID | jq -c '.ResourceRecordSets[]' | \
  while read -r resourcerecordset; do
    read -r name type <<<$(echo $(jq -r '.Name,.Type' <<<"$resourcerecordset"))

     if [ $type != "NS" -a $type != "SOA" ]; then
        aws route53 change-resource-record-sets \
          --hosted-zone-id $ZONE_ID \
          --change-batch '{"Changes":[{"Action":"DELETE","ResourceRecordSet":
          '"$resourcerecordset"'
        }]}' \
        --output text --query 'ChangeInfo.Id' >/dev/null 2>&1
     fi
  done

  aws route53 delete-hosted-zone --id $ZONE_ID >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to delete AWS Route53 zone $ZONE_ID"
    echo "       => aws route53 delete-hosted-zone --id $ZONE_ID"
    #exit 1
  fi
}

checkKeyPairs_old() {
echo hallo1
  SSH_KEY_NAME=vmware-cloud-tmc
  SSH_KEY_FILE=~/.tanzu-demo-hub/KeyPair-${SSH_KEY_NAME}-${AWS_REGION}.pem

echo hallo2
  #"KeyFingerprint": "a8:c4:01:2b:12:7e:0d:8f:56:8c:38:80:cf:8b:6d:53:13:9c:28:cd",
  #aws ec2 --region=eu-central-1 create-key-pair --dry-run --key-name sacha
  #/tmp/key.pem
echo hallo3

  if [ ! -d ~/.tanzu-demo-hub ] ; then mkdir ~/.tanzu-demo-hub; fi
echo hallo4

  # --- VERIFY KEY-PAIR ---
  key=$(aws ec2 --region=$AWS_REGION describe-key-pairs | \
        jq -r --arg key "$SSH_KEY_NAME" '.KeyPairs[] | select(.KeyName == $key).KeyFingerprint')
echo hallo5

  # --- CREATE ONE IF IT DOES NOT EXIST ---
  if [ "${key}" == "" ]; then
    aws ec2 --region=$AWS_REGION create-key-pair --key-name vmware-cloud-tmc | \
       jq -r '.KeyMaterial' > $SSH_KEY_FILE
    chmod 600 $SSH_KEY_FILE
  fi
echo hallo6

  if [ -f "${SSH_KEY_FILE}" ]; then
    kfp=$(openssl pkcs8 -in $SSH_KEY_FILE -inform PEM -outform DER -topk8 -nocrypt | openssl sha1 -c)

    if [ "${key}" != "${kfp}" ]; then
      echo "ERROR: Fingerprint of AWS SSH Key-pair ($SSH_KEY_NAME) and the local PEM file: "
      echo "       $SSH_KEY_FILE are not the same"
      exit
    fi
  fi
echo hallo7
}

maskPassword() {
  echo "$1" | sed 's/[^-]/X/g'
}

route53getIPaddress() {
  env=$1
  dom=$2
  hst="jump-${env}.${dom}."
  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$dom.\")).Id")
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID_STR --query "ResourceRecordSets[?Name == '${hst}']" | \
  jq -r '.[].ResourceRecords[].Value'
}

#route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
route53setDNSrecord() {
  ipa=$1; hnm=$2; dom=$3

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r '.HostedZones[0].Id')
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
  if [ "${ZONE_ID}" == "" ]; then
    echo "ERROR: ZoneID for domain $dom can not be optained, please veriofy manually"
    echo "       aws route53 list-hosted-zones-by-name --dns-name ${dom}"
    exit 1
  fi

cat << EOF | sed -e "s/FQHN/$hnm/g" -e "s/IPADDR/$ipa/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN",
                                    "Type": "A",
                                    "TTL": 300,
                                 "ResourceRecords": [{ "Value": "IPADDR"}]
}}]
}
EOF

   aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record > /dev/null 2>&1
   if [ $? -ne 0 ]; then
     echo "ERROR: failed to set DNS for $hnm"
     echo "       => aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record"
     cat /tmp/$$_zone_record
     exit 1
   fi
}

createCluster() {
  unset TKG_CONFIG
  TKG_TEMPLATE=${HOME}/.tanzu-demo-hub/${TDH_TKGMC_CONFIG}
  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "Azure" ]; then
    MDOE=azure
    messageTitle "Creating TKG Managment Cluster"
    messagePrint " - Cluster Name"                "$TDH_TKGMC_NAME"
    messagePrint " - Configuration File"          "$TKG_TEMPLATE"
    messagePrint " - Control Plane Machine Type"  "$TDH_TKGMC_CONTROL_PLANE_MACHINE_TYPE"
    messagePrint " - Worker Node Machine Type"    "$TDH_TKGMC_MACHINE_TYPE"
    messagePrint " - Cluster CIDR"                "$TDH_TKGMC_CLUSTER_CIDR"
    messagePrint " - Service CIDR"                "$TDH_TKGMC_SERVICE_CIDR"
    messagePrint " - Health Check Enabled"        "$TDH_TKGMC_MACHINE_HEALTH_CHECK_ENABLED"

    [ -f ${HOME}/.tkg/config.yaml ] && rm -f ${HOME}/.tkg/config.yaml
    tkg get mc > /dev/null 2>&1
    cp ${HOME}/.tkg/config.yaml $TKG_TEMPLATE

    AZURE_SSH_PUBLIC_KEY_B64=$(cat ~/.tanzu-demo-hub/KeyPair-Azure.pub | base64 -w 10000)

    echo "AZURE_SSH_PUBLIC_KEY_B64: $AZURE_SSH_PUBLIC_KEY_B64"                        >> $TKG_TEMPLATE
    echo "AZURE_NODE_MACHINE_TYPE: $TDH_TKGMC_MACHINE_TYPE"                           >> $TKG_TEMPLATE
    echo "AZURE_TENANT_ID: $AZURE_TENANT_ID"                                          >> $TKG_TEMPLATE
    echo "AZURE_CLIENT_ID: $AZURE_CLIENT_ID"                                          >> $TKG_TEMPLATE
    echo "AZURE_CLIENT_SECRET: $AZURE_CLIENT_SECRET"                                  >> $TKG_TEMPLATE
    echo "AZURE_CONTROL_PLANE_MACHINE_TYPE: $TDH_TKGMC_CONTROL_PLANE_MACHINE_TYPE"    >> $TKG_TEMPLATE
    echo "SERVICE_CIDR: $TDH_TKGMC_SERVICE_CIDR"                                      >> $TKG_TEMPLATE
    echo "CLUSTER_CIDR: $TDH_TKGMC_CLUSTER_CIDR"                                      >> $TKG_TEMPLATE
    echo "AZURE_LOCATION: $AZURE_LOCATION"                                            >> $TKG_TEMPLATE
    echo "AZURE_SUBSCRIPTION_ID: $AZURE_SUBSCRIPTION_ID"                              >> $TKG_TEMPLATE

    stt=$(tkg get mc --name $TDH_TKGMC_NAME -o json | jq -r '.[].status')
    if [ "${stt}" != "Success" ]; then
      echo "----------------------------------------------------------------------------------------------------------------"
      echo "tkg init -q -i $MPDE -p dev --ceip-participation true --cni $TDH_TKGMC_CNI -v 0 \\"
      echo "         --name $TDH_TKGMC_NAME --config $TKG_TEMPLATE"
      echo "----------------------------------------------------------------------------------------------------------------"
      time tkg init -i $MPDE -p dev --ceip-participation true --cni $TDH_TKGMC_CNI -v 0 --name $TDH_TKGMC_NAME --config $TKG_TEMPLATE
      echo "----------------------------------------------------------------------------------------------------------------"
    fi
  fi

  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "vSphere" ]; then
    MODE=vsphere
    MC_CLUSTER_STATUS=1  ### MC-CLUSTER IS ACTIVE

    if [ -f $TKG_TEMPLATE ]; then 
      stt=$(tkg get mc --name $TDH_TKGMC_NAME -o json --config $TKG_TEMPLATE | jq -r '.[].status')
      if [ "${stt}" != "Success" ]; then
        rm -f $TKG_TEMPLATE
        MC_CLUSTER_STATUS=0
      fi
    else
      MC_CLUSTER_STATUS=0
    fi

    if [ $MC_CLUSTER_STATUS -eq 0 ]; then 
      messageTitle "Creating TKG Managment Cluster"
      messagePrint " - Cluster Name"                "$TDH_TKGMC_NAME"
      messagePrint " - Configuration File"          "$TKG_TEMPLATE"
      messagePrint " - Control Plane Machine Type"  "$TDH_TKGMC_CONTROL_PLANE_MACHINE_TYPE"
      messagePrint " - Worker Node Machine Type"    "$TDH_TKGMC_MACHINE_TYPE"
      messagePrint " - Cluster CIDR"                "$TDH_TKGMC_CLUSTER_CIDR"
      messagePrint " - Service CIDR"                "$TDH_TKGMC_SERVICE_CIDR"
      messagePrint " - Health Check Enabled"        "$TDH_TKGMC_MACHINE_HEALTH_CHECK_ENABLED"

      export GOVC_INSECURE=1
      export GOVC_URL=https://${VSPHERE_SERVER}/sdk
      export GOVC_USERNAME=$VSPHERE_ADMIN
      export GOVC_PASSWORD=$VSPHERE_PASSWORD
      export GOVC_DATASTORE=$VSPHERE_DATASTORE
      export GOVC_NETWORK="$VSPHERE_MANAGEMENT_NETWORK"
      export GOVC_RESOURCE_POOL=/${VSPHERE_DATACENTER}/host/${VSPHERE_CLUSTER}/Resources

      nodes=$(govc find -name "$TDH_TKGMC_NAME*")
      if [ $? != 0 ]; then 
        echo "ERROR: failed to login to vSphere"
        echo "       => govc find -name \"$TDH_TKGMC_NAME*\""; exit
      fi

      for n in $nodes; do
        messagePrint " - Cleanup Old Cluster Nodes"  "$n"
        govc vm.destroy $n > /dev/null 2>&1
        if [ $? != 0 ]; then 
          echo "ERROR: failed to login to vSphere"
          echo "       => govc vm.destroy $n"; exit 
        fi
      done

      for n in $(kind get clusters); do
        messagePrint " - Cleanup local kind Clusters:"  "$n"
        kind delete clusters $n > /dev/null 2>&1
      done

      [ -f ${HOME}/.tkg/config.yaml ] && rm -f ${HOME}/.tkg/config.yaml
      tkg get mc > /dev/null 2>&1
      cp ${HOME}/.tkg/config.yaml $TKG_TEMPLATE

      echo "VSPHERE_WORKER_MEM_MIB: 2048"                                                 >> $TKG_TEMPLATE
      echo "_VSPHERE_CONTROL_PLANE_ENDPOINT_IP: 10.1.1.30"                                >> $TKG_TEMPLATE
      echo "VSPHERE_CONTROL_PLANE_DISK_GIB: 20"                                           >> $TKG_TEMPLATE
      echo "VSPHERE_PASSWORD: <encoded:$(eval printf \"$VSPHERE_PASSWORD\" | base64)>"    >> $TKG_TEMPLATE
      echo "VSPHERE_NETWORK: Management"                                                  >> $TKG_TEMPLATE
      echo "VSPHERE_WORKER_NUM_CPUS: \"2\""                                               >> $TKG_TEMPLATE
      echo "VSPHERE_USERNAME: $VSPHERE_ADMIN"                                             >> $TKG_TEMPLATE
      echo "VSPHERE_FOLDER: /CoreDC/vm/Templates"                                         >> $TKG_TEMPLATE
      echo "SERVICE_CIDR: $TDH_TKGMC_SERVICE_CIDR"                                        >> $TKG_TEMPLATE
      echo "CLUSTER_CIDR: $TDH_TKGMC_CLUSTER_CIDR"                                        >> $TKG_TEMPLATE
      echo "VSPHERE_CONTROL_PLANE_NUM_CPUS: \"2\""                                        >> $TKG_TEMPLATE
      echo "VSPHERE_WORKER_DISK_GIB: \"20\""                                              >> $TKG_TEMPLATE
      echo "VSPHERE_SSH_AUTHORIZED_KEY: |-"                                               >> $TKG_TEMPLATE
      cat $VSPHERE_SSH_PUBLIC_KEY_FILE | sed 's/^/    /g'                                 >> $TKG_TEMPLATE
      echo "VSPHERE_SERVER: $TDH_TKGMC_VCENTER_SERVER"                                    >> $TKG_TEMPLATE
      echo "VSPHERE_DATASTORE: /$VSPHERE_DATACENTER/datastore/$VSPHERE_DATASTORE"         >> $TKG_TEMPLATE
      echo "VSPHERE_RESOURCE_POOL: /$VSPHERE_DATACENTER/host/$VSPHERE_CLUSTER/Resources"  >> $TKG_TEMPLATE
      echo "VSPHERE_CONTROL_PLANE_MEM_MIB: \"2048\""                                      >> $TKG_TEMPLATE
      echo "MACHINE_HEALTH_CHECK_ENABLED: \"true\""                                       >> $TKG_TEMPLATE
      echo "VSPHERE_DATACENTER: /$VSPHERE_DATACENTER"                                     >> $TKG_TEMPLATE

      echo "----------------------------------------------------------------------------------------------------------------"
      echo "tkg init -q -i $MODE -p dev --vsphere-controlplane-endpoint-ip $VSPHERE_CONTROLPLANE_IP \\"
      echo "         --ceip-participation true --cni $TDH_TKGMC_CNI -v 0 \\"
      echo "         --name $TDH_TKGMC_NAME --config $TKG_TEMPLATE"
      echo "----------------------------------------------------------------------------------------------------------------"
      time tkg init -i $MODE -p dev --vsphere-controlplane-endpoint-ip $VSPHERE_CONTROLPLANE_IP --ceip-participation true \
           --cni $TDH_TKGMC_CNI -v 0 --name $TDH_TKGMC_NAME --config $TKG_TEMPLATE
      echo "----------------------------------------------------------------------------------------------------------------"
    else
      messageTitle "Verify TKG Managment Cluster"
      messagePrint " - Cluster Name"                "$TDH_TKGMC_NAME"
      messagePrint " - Configuration File"          "$TKG_TEMPLATE"
      messagePrint " - Control Plane Machine Type"  "$TDH_TKGMC_CONTROL_PLANE_MACHINE_TYPE"
      messagePrint " - Worker Node Machine Type"    "$TDH_TKGMC_MACHINE_TYPE"
      messagePrint " - Cluster CIDR"                "$TDH_TKGMC_CLUSTER_CIDR"
      messagePrint " - Service CIDR"                "$TDH_TKGMC_SERVICE_CIDR"
      messagePrint " - Health Check Enabled"        "$TDH_TKGMC_MACHINE_HEALTH_CHECK_ENABLED"
    fi
  fi
}

setTKGclusterDNS() {
  TKG_CLUSTER="$1"
  TKG_IPADRESS="$2"
  TKG_INGRESS="$3"
  DNS_PREFIX="$TDH_TKGMC_ENVNAME"
  DNS_SUFFIX="$AWS_HOSTED_DNS_DOMAIN"

  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "AWS" ]; then
    AWS_ID=$(echo $DNSLB | awk -F '-' '{ print $1 }')
    AWS_LB="k8s-master-$TKG_CLUSTER"
    AWS_SG=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names $AWS_ID | \
             jq -r '.LoadBalancerDescriptions[].SecurityGroups[]')
    AWS_VP=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names $AWS_ID | \
             jq -r '.LoadBalancerDescriptions[].VPCId')
  
    cnt=$(echo "${AWS_SG}" | egrep -c "$AWS_SG_NEW")
    if [ $cnt -eq 0 ]; then
      a=1
    fi
  fi
  
  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "GCP" ]; then
    DNS_NAME="*.${TKG_INGRESS}-${TKG_CLUSTER}"
    messagePrint "- Create DNS Entry for:" "*.${TKG_INGRESS}-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"
  
    cnt=$(gcloud dns record-sets list -z ${DNS_PREFIX}-zone --name "${DNS_NAME}.${DNS_PREFIX}.${DNS_SUFFIX}." \
            --type=A 2> /dev/null | grep -v "^NAME" | wc -l | sed 's/ //g')
    if [ ${cnt} -eq 0 ]; then
      messagePrint " - Creating DNS Entry in (${DNS_PREFIX}-zone)" "${DNS_NAME}"
      gcloud dns record-sets transaction abort -z ${DNS_PREFIX}-zone > /dev/null 2>&1
      gcloud dns record-sets transaction start -z ${DNS_PREFIX}-zone > /dev/null 2>&1
      gcloud dns record-sets transaction add "$DNSLB" --name "${DNS_NAME}.${DNS_PREFIX}.${DNS_SUFFIX}." \
         --type A -z ${DNS_PREFIX}-zone --ttl=300 > /dev/null 2>&1
      gcloud dns record-sets transaction execute -z ${DNS_PREFIX}-zone > /dev/null 2>&1; ret=$?
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: Creating DNS record-sets for zone (${DNS_PREFIX}-zone)"
        echo "       => gcloud dns record-sets transaction execute -z ${DNS_PREFIX}-zone"
        exit 1
      fi
    fi
  fi
  
  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "Azure" ]; then
    DNS_NAME="*.${TKG_INGRESS}-${TKG_CLUSTER}"
    messagePrint "- LoadBalancer PublicIP:" "$TKG_IPADRESS"
    messagePrint "- Create DNS Entry for:" "*.${TKG_INGRESS}-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"

    ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_PREFIX}.${DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
    ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

    if [ "${ZONE_ID}" != "" ]; then
      ZONE="*.${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"
      ZONE="*.${TKG_INGRESS}-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"

      TMPROUTE53=/tmp/$$_tmp_route53.json
      echo "{"                                                            >  $TMPROUTE53
      echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","           >> $TMPROUTE53
      echo "  \"Changes\": [{"                                            >> $TMPROUTE53
      echo "    \"Action\": \"UPSERT\","                                  >> $TMPROUTE53
      echo "    \"ResourceRecordSet\": {"                                 >> $TMPROUTE53
      echo "      \"Name\": \"${ZONE}\","                                 >> $TMPROUTE53
      echo "      \"Type\": \"A\","                                       >> $TMPROUTE53
      echo "      \"TTL\": 300,"                                          >> $TMPROUTE53
      echo "      \"ResourceRecords\": [{ \"Value\": \"$TKG_IPADRESS\"}]" >> $TMPROUTE53
      echo "    }"                                                        >> $TMPROUTE53
      echo "  }]"                                                         >> $TMPROUTE53
      echo "}"                                                            >> $TMPROUTE53

      aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
          --change-batch file://${TMPROUTE53} > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        echo "ERROR: failed to set DNS for $hnm"
        echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
        echo "              --change-batch file://${TMPROUTE53}"
        cat $TMPROUTE53
        exit 1
      fi

      rm -f $TMPROUTE53
    fi
  fi

  if [ "${AWS_HOSTED_ZONE_ID}" != "" -a "${TDH_TKGMC_INFRASTRUCTURE}" == "AWS" ]; then
    ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
    DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
        jq -r '.LoadBalancerDescriptions[0].DNSName')
    DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
        jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')
    ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_PREFIX}.${DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
  
    ALIAS=$(aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID \
            --query "ResourceRecordSets[?contains(Name, '${TKG_INGRESS}-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}')].AliasTarget.DNSName" | \
            jq -r '.[]' | sed -e 's/dualstack\.//g' -e 's/\.$//g' )
  
    if [ "${ALIAS}" != "$DNSLB" ]; then
      if [ "${ZONE_ID}" != "" ]; then
        echo "Create DNS Entry for *.${TKG_INGRESS}-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}:"
        ZONE="*.${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"
        ZONE="*.${TKG_INGRESS}-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"
  
        TMPROUTE53=/tmp/$$_tmp_route53.json
        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${ZONE}\","                          >> $TMPROUTE53
        echo "    \"Type\": \"A\","                                >> $TMPROUTE53
        echo "    \"AliasTarget\": {"                              >> $TMPROUTE53
        echo "      \"HostedZoneId\": \"${DNSLB_ZONEID}\","        >> $TMPROUTE53
        echo "      \"DNSName\": \"dualstack.${DNSLB}.\","         >> $TMPROUTE53
        echo "      \"EvaluateTargetHealth\": true"                >> $TMPROUTE53
        echo "    }"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53
  
        aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failed to set DNS for $hnm"
          echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
          echo "              --change-batch file://${TMPROUTE53}"
          cat $TMPROUTE53
          exit 1
        fi
  
        rm -f $TMPROUTE53
      fi
    fi
  fi
}

verifyTLScertificate() {
  TLS_CERTIFICATE=$1
  TLS_PRIVATE_KEY=$2

  dif=$((openssl x509 -in $TLS_CERTIFICATE -noout -modulus; openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus) | \
      uniq -c | awk '{ print $1 }')
  if [ "$dif" == "" ]; then dif=0; fi
  if [ $dif -ne 2 ]; then
    echo "ERROR: Certificate modulus of $TLS_CERTIFICATE does not match with the private_key $TLS_PRIVATE_KEY"
    echo "       => openssl x509 -in $TLS_CERTIFICATE -noout -modulus"
    echo "       => openssl rsa -in $TLS_PRIVATE_KEY -noout -modulus"
    exit 1
  fi

  if [ ! -f ${TDHPATH}/certificates/ca.pem ]; then
    # --- TRY TO FIND THE ROOT_CA ---
    if [ "${ROOT_CA_NAME}" == "DST Root CA X3" ]; then
      ROOT_CA_URL="https://letsencrypt.org/certs/trustid-x3-root.pem.txt"
      curl --output /tmp/trustid-x3-root.pem $ROOT_CA_URL > /dev/null 2>&1
      TLS_ROOT_CA=/tmp/trustid-x3-root.pem
      #eval export ${CLOUD}_${MODE}_TLS_ROOT_CA=/tmp/trustid-x3-root.pem
    fi

    # --- GENERATE CA.PEM WITH ROOT_CA AND FULLCHAIN ---
    cat $TLS_ROOT_CA $TLS_CERTIFICATE > ${TDHPATH}/certificates/ca.pem

    if [ "${TLS_ROOT_CA}" == "" ]; then
      echo "ERROR: ROOT_CA for $ROOT_CA_NAME could not be found, please download the file manually"
      echo "       and set the variable in the ~/.pcfconfig"
      echo "       => export ${CLOUD}_${MODE}_TLS_ROOT_CA=<ca.crt>"
      exit 1
    fi
  fi

}

verifyCertificate () {
  CLOUD="$1"
  TLS_CERTIFICATE="$2"
  TLS_FULLCHAIN="$3"
  TLS_PRIVATE_KEY="$4"
  TLS_CHAIN="$5"
  TLS_ROOT_CA="$6"


echo "CLOUD:$CLOUD"
echo "CLOUD:$CLOUD"
echo "CLOUD:$CLOUD"
echo "CLOUD:$CLOUD"

exit

  if [ "${TLS_CERTIFICATE}" == "" -o "${TLS_PRIVATE_KEY}" == "" -o \
       "${TLS_FULLCHAIN}" == "" ]; then

    echo ""
    echo "  3MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  To allow TLS encrypted httpd traffic a Certificate and key needs to be created for your DNS Domain. Free"
    echo "  certificates can be optained through https://letsencrypt.org."
    echo ""

    if [ "${TLS_CERTIFICATE}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_CERTIFICATE       (optional)  TLS Certificate (type PEM Certificate)"
    fi

    if [ "${TLS_FULLCHAIN}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_FULLCHAIN         (optional)  TLS Fullchain (type PEM Certificate)"
    fi

    if [ "${TLS_PRIVATE_KEY}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_PRIVATE_KEY       (optional)  TLS Private Key"
    fi

    if [ "${ROOT_CA}" == "" ]; then
      echo "  ${CLOUD}_${MODE}_TLS_ROOT_CA           (automatic) TLS Root CA"
    fi

    dom="$PCF_DEPLOYMENT_ENV_NAME.$AWS_HOSTED_DNS_DOMAIN"
    echo "                                  "
    echo "                                  $PCF_DEPLOYMENT_ENV_NAME.$AWS_HOSTED_DNS_DOMAIN"
    echo "                                    |      |_________ represented by the PCF_ENVIRONMENT_NAME variable"
    echo "                                    |________________ represented by the AWS_HOSTED_DNS_DOMAIN variable"
    echo ""
    echo "                                  The certificate Should include the following domains:"
    echo "                                  - PKS Services (API, OpsMan, Harbor) .: *.${dom}"
    echo "                                  - PKS Cluster and Applications .......: *.apps.cl1.${dom}"
    echo "                                                                          *.apps.cl2.${dom}"
    echo "                                                                          *.apps.cl3.${dom}"
    echo ""
  else
    messageTitle "TLS Encryption for domain (${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN})"

    for n in $TLS_CERTIFICATE $TLS_FULLCHAIN; do
      cnt=$(grep -c "BEGIN CERTIFICATE" $n)
      if [ $cnt -eq 0 ]; then
        echo "ERROR: The file ($n) is not in (Base64) format"
        echo "       It should begin with '-----BEGIN CERTIFICATE-----' and end with '-----END CERTIFICATE-----'"
        exit 1
      fi
    done

    for n in $TLS_PRIVATE_KEY; do
      cnt=$(egrep -c "BEGIN RSA PRIVATE|BEGIN PRIVATE" $n)
      if [ $cnt -eq 0 ]; then
        echo "ERROR: The file ($n) is not (private-key Base64) format"
        echo "       It should begin with '-----BEGIN RSA PRIVATE' and end with '-----END RSA PRIVATE'"
        exit 1
      fi
    done

    # --- VERIFY THE CERTIFICATE ---
    cnm="${PCF_DEPLOYMENT_ENV_NAME}.${AWS_HOSTED_DNS_DOMAIN}"
    cnt=$(openssl crl2pkcs7 -nocrl -certfile $TLS_FULLCHAIN | openssl pkcs7 -print_certs | egrep "^subject|^issuer" | \
          sed -e 's/CN = /CN=/g' -e 's/^subject=.*CN=//g' -e 's/^issuer=.*CN=//g' | egrep -c "^\*.${cnm}")
    if [ $cnt -eq 0 ]; then
      echo "ERROR: The file ($(basename $TLS_FULLCHAIN)) does not contain the CN=*.${cnm}"
      exit 1
    fi

    ISSUER="*.${cnm}"; item_found=1
    while [ ${item_found} -eq 1 ]; do
      item_found=0
      for item in $(openssl crl2pkcs7 -nocrl -certfile $TLS_FULLCHAIN | openssl pkcs7 -print_certs | \
                    egrep "^subject|^issuer" | sed -e 's/CN = /CN=/g' -e 's/^subject=.*CN=//g' \
                    -e 's/^issuer=.*CN=//g' -e 's/ /~1~/g' | paste -d ':' - -); do

        sub=$(echo "${item}" | awk -F: '{ print $1 }')
        iss=$(echo "${item}" | awk -F: '{ print $2 }')

        if [ "${sub}" == "${ISSUER}" ]; then ISSUER="${iss}"; SUBJECT="${sub}"; item_found=1; fi
      done
    done

    ROOT_CA=$ISSUER
    ROOT_CA_NAME=$(echo $ISSUER | sed 's/~1~/ /g')

    if [ "${TLS_ROOT_CA}" == "" ]; then
      # --- TRY TO FIND THE ROOT_CA ---
      if [ "${ROOT_CA_NAME}" == "DST Root CA X3" ]; then
        ROOT_CA_URL="https://letsencrypt.org/certs/trustid-x3-root.pem.txt"
        curl --output /tmp/trustid-x3-root.pem $ROOT_CA_URL > /dev/null 2>&1
        TLS_ROOT_CA=/tmp/trustid-x3-root.pem
        eval export ${CLOUD}_${MODE}_TLS_ROOT_CA=/tmp/trustid-x3-root.pem
      fi

      # --- GENERATE CA.PEM WITH ROOT_CA AND FULLCHAIN ---
      cat $TLS_ROOT_CA $TLS_FULLCHAIN > $HOME/pcfconfig/certificates/ca.pem

      if [ "${TLS_ROOT_CA}" == "" ]; then
        echo "ERROR: ROOT_CA for $ROOT_CA_NAME could not be found, please download the file manually"
        echo "       and set the variable in the ~/.pcfconfig"
        echo "       => export ${CLOUD}_${MODE}_TLS_ROOT_CA=<ca.crt>"
        exit 1
      fi
    fi

    # --- VERIFY TO ROOT_CA ---
    for n in $TLS_ROOT_CA; do
      if [ ! -f $n ]; then
        echo "ERROR: the file $n does not exist"; exit 1
      fi

      cnt=$(grep -c "BEGIN CERTIFICATE" $n)
      if [ $cnt -eq 0 ]; then
        echo "ERROR: The file ($(basename $n)) is not in (Base64) format"
        echo "       It should begin with '-----BEGIN CERTIFICATE-----' and end with '-----END CERTIFICATE-----'"
        exit 1
      fi
    done

    # --- VERIFY THE CERTIFICATE ISSUER AND SUBJECT ---
    tmp=$(openssl crl2pkcs7 -nocrl -certfile $TLS_ROOT_CA | openssl pkcs7 -print_certs | \
          egrep "^subject|^issuer" | sed -e 's/CN = /CN=/g' -e 's/^subject=.*CN=//g' -e 's/^issuer=.*CN=//g' -e 's/ /~1~/g' | \
          paste -d ':' - -)
    sub=$(echo "${tmp}" | awk -F: '{ print $1 }' | sed 's/~1~/ /g')
    iss=$(echo "${tmp}" | awk -F: '{ print $2 }' | sed 's/~1~/ /g')
    if [ "${iss}" != "${sub}" ]; then
      echo "ERROR: $TLS_ROOT_CA is not a Root CA. Issuer and Subject should be the same"
      echo "       => File: $TLS_ROOT_CA Issuer=$sub / Subject=$iss"
      exit 1
    fi

    if [ "${iss}" != "${ROOT_CA_NAME}" ]; then
      echo "ERROR: $TLS_ROOT_CA is not Signed by $ROOT_CA_NAME."
      echo "       => File: $TLS_ROOT_CA Subject=$iss"
      exit 1
    fi

    # --- VERIFY CERTITICATE AND FULLCHAAIN SIGNED BY ROOT_CA ---
    cat $TLS_ROOT_CA $TLS_FULLCHAIN > /tmp/ca.crt
    openssl verify -CAfile /tmp/ca.crt $TLS_CERTIFICATE > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: Certificate ($TLS_CERTIFICATE) was not signed by the Roor CA ($ROOT_CA_NAME)"
      exit 1
    fi

    openssl verify -CAfile /tmp/ca.crt $TLS_FULLCHAIN > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: Certificate ($TLS_FULLCHAIN) was not signed by the Roor CA ($ROOT_CA_NAME)"
      exit 1
    fi

   # --- VERIFY IF PRIVATE KEY MATCH THE CERTIFICATE ---
    pk=$(openssl rsa  -noout -modulus -in $TLS_PRIVATE_KEY | openssl md5)
    cr=$(openssl x509 -noout -modulus -in $TLS_CERTIFICATE | openssl md5)
    fc=$(openssl x509 -noout -modulus -in $TLS_FULLCHAIN | openssl md5)

    if [ "${pk}" != "${cr}" ]; then
      echo "ERROR: Cert ($(basename $TLS_CERTIFICATE)) does not match the private key ($(basename $TLS_PRIVATE_KEY))"
      echo "       => openssl rsa -noout -modulus -in $TLS_PRIVATE_KEY | openssl md5"
      echo "       => openssl x509 -noout -modulus -in $TLS_CERTIFICATE | openssl md5"
      exit 1
    fi

    if [ "${pk}" != "${fc}" ]; then
      echo "ERROR: Cert ($(basename $TLS_FULLCHAIN)) does not match the private key ($(basename $TLS_PRIVATE_KEY))"
      echo "       => openssl rsa -noout -modulus -in $TLS_PRIVATE_KEY | openssl md5"
      echo "       => openssl x509 -noout -modulus -in $TLS_FULLCHAIN | openssl md5"
      exit 1
    fi

    messagePrint " - TLS Certificate"                  "$TLS_CERTIFICATE"
    messagePrint " - TLS fullchain"                    "$TLS_FULLCHAIN"
    messagePrint " - TLS Private Key"                  "$TLS_PRIVATE_KEY"
    messagePrint " - TLS Root CA ($ROOT_CA_NAME)"      "$TLS_ROOT_CA"
  fi
}

setDNSrecord() {
  TKG_IPADRESS="$1"
  DNS_PREFIX="$2"
  DNS_SUFFIX="$3"
  HOSTNAME="$4"
  
  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_PREFIX}.${DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

  if [ "${ZONE_ID}" != "" ]; then
    ZONE="${HOSTNAME}.${DNS_PREFIX}.${DNS_SUFFIX}"

    TMPROUTE53=/tmp/$$_tmp_route53.json
    echo "{"                                                            >  $TMPROUTE53
    echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","           >> $TMPROUTE53
    echo "  \"Changes\": [{"                                            >> $TMPROUTE53
    echo "    \"Action\": \"UPSERT\","                                  >> $TMPROUTE53
    echo "    \"ResourceRecordSet\": {"                                 >> $TMPROUTE53
    echo "      \"Name\": \"${ZONE}\","                                 >> $TMPROUTE53
    echo "      \"Type\": \"CNAME\","                                       >> $TMPROUTE53
    echo "      \"TTL\": 300,"                                          >> $TMPROUTE53
    echo "      \"ResourceRecords\": [{ \"Value\": \"$TKG_IPADRESS\"}]" >> $TMPROUTE53
    echo "    }"                                                        >> $TMPROUTE53
    echo "  }]"                                                         >> $TMPROUTE53
    echo "}"                                                            >> $TMPROUTE53

    aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
        --change-batch file://${TMPROUTE53} > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      echo "ERROR: failed to set DNS for $hnm"
      echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
      echo "              --change-batch file://${TMPROUTE53}"
      cat $TMPROUTE53
      exit 1
    fi

    rm -f $TMPROUTE53
  fi
}
