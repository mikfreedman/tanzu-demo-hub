#!/bin/bash
# ############################################################################################
# File: ........: functions
# Language .....: bash
# Author .......: Sacha Dubois, VMware
# Description ..: Tanzu Demo Hub - Cluster Installation
# ############################################################################################

waitCmd() {
  read
}

prtHead() {
  if [ "${tocindex}" == "" ]; then tocindex=1; else let tocindex=tocindex+1; fi
  printf "%2d.) %s\n" $tocindex "$1"
}

prtText() {
  if [ "${tocindex}" == "" ]; then tocindex=1; else let tocindex=tocindex+1; fi
  printf "%2s   %s\n" "" "$1"
}

execCmd() {
  bold=$(tput bold)
  normal=$(tput sgr0)

  echo -e "     => ${bold}$1${normal}\c"; read x
  echo "     -----------------------------------------------------------------------------------------------------------"
  eval "$1" 2>&1 | sed -e '/^$/d' -e 's/^/     /g'
  #$1 | sed -e '/^$/d' -e 's/^/     /g'
  echo "     -----------------------------------------------------------------------------------------------------------"
  echo ""
  if [ $? -ne 0 ]; then exit 1; fi
}

tmcCheckLogin() {
  tmc cluster list >/dev/null 2>&1

  if [ $? -ne 0 ]; then 
    echo "ERROR: Currently not logged in in TMC, please login: tmc login"
    exit 1
  fi
}

messageTitle() {
  _msg="$*"
  _dat=$(date "+%Y%m%d-%H:%M:%S")

  if [ "${PCF_DEPLOYMENT_DEBUG}" == "true" -o "${DEBUG}" == "1" ]; then
    echo "[${_dat}] ${_msg}"
  else
    echo "${_msg}"
  fi
}

messagePrint() {
  _msg="$1"
  _stt="$2"
  _cnt=$(echo "${_msg}" | wc -c | sed 's/ //g')
  _dat=$(date "+%Y%m%d-%H:%M:%S")

  _str=""
  while [ $_cnt -lt 58 ]; do
    _str="${_str}."
    let _cnt=_cnt+1
  done

  # --- INIZIALIZE VALUES IF EMPTY --- ---
  [ "$DEBUG" == "" ] && DEBUG=0

  if [ "${PCF_DEPLOYMENT_DEBUG}" == "true" -o "${DEBUG}" == "1" ]; then
    echo "[${_dat}] ${_msg} ${_str}: ${_stt}"
  else
    echo "${_msg} ${_str}: ${_stt}"
  fi
}

sshEnvironment() {
  JUMP_HOST="jump-${TDH_TKGMC_ENVNAME}.${AWS_HOSTED_DNS_DOMAIN}"

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" -o "${TDH_TKGMC_INFRASTRUCTURE}" ]; then
    pip=""
    while [ "$pip" == "" -o "$pip" == "null" ]; do
      pip=$(az network public-ip list -g Admin --query "[?contains(name, 'AdminPublicIP_$TDH_TKGMC_ENVNAME')]" | \
            jq -r '.[].ipAddress')
      sleep 10
    done

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_PRIVATE_KEY=~/.tanzu-demo-hub/KeyPair-Azure.pem
    SSH_HOST=$pip
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=240 -o ClientAliveInterval=240"
    SSH_OPTIONS="-o StrictHostKeyChecking=no"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i ${SSH_PRIVATE_KEY} ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -i ${SSH_PRIVATE_KEY} -r $SCP_OPTIONS"
    SSH_DISPLAY="ssh $SSH_OPTIONS -i ${SSH_PRIVATE_KEY} ${SSH_USER}@${SSH_HOST}"
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    SSH_HOST=$(aws ec2 --region=$AWS_REGION describe-instances \
                     --filters Name=tag:sigs.k8s.io/cluster-api-provider-aws/role,Values="bastion" | \
             jq -r '.Reservations[].Instances[].PublicDnsName')

    SSH_USER=ubuntu
    SSH_HOME=/home/ubuntu
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SSH_DISPLAY="-o StrictHostKeyChecking=no"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS -i $SSH_KEY_FILE ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS -i $SSH_KEY_FILE"
    SSH_DISPLAY="ssh -i $SSH_KEY_FILE ${SSH_USER}@${SSH_HOST}"
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    INSTANCE_NAME="$(echo $JUMP_HOST | awk -F'.' '{ print $1 }')"
    #ZONE=$(gcloud compute zones list | grep " $GCP_REGION " | head -1 | awk '{ print $1 }')
    ZONE=$(gcloud compute instances list --filter="name=( '$INSTANCE_NAME')" | egrep "^$INSTANCE_NAME" | awk '{ print $2 }')

    prj=$(gcloud projects list | sed '1d' | awk '{ print $1 }')
    prj=${GCP_PROJECT}

    SSH_USER=$(whoami)
    SSH_HOME=/home/$(whoami)
    SSH_HOST="${INSTANCE_NAME}.${ZONE}.${prj}"
    SSH_OPTIONS="-o StrictHostKeyChecking=no -o RequestTTY=yes -o ServerAliveInterval=30"
    SCP_OPTIONS="-o StrictHostKeyChecking=no"
    SSH_COMMAND="ssh -q $SSH_OPTIONS ${SSH_USER}@${SSH_HOST}"
    SCP_COMMAND="scp -r $SCP_OPTIONS"
    SSH_DISPLAY="ssh ${SSH_USER}@${SSH_HOST}"
  fi

  echo "--------------------------------- JUMP SERVER ACCESS ------------------------------------------------------"
  echo "$SSH_DISPLAY"
  echo "-----------------------------------------------------------------------------------------------------------"
}

checkCloudCLI() {
  if [ "${TDH_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    # --- CHECK FOR AWS CLI ---
    GCLOUD=$(which gcloud)
    if [ "${GCLOUD}" != "" ]; then
      $GCLOUD --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        GCLOUD_VERSION=$($GCLOUD --version 2>/dev/null | grep "Google Cloud SDK" | awk '{ print $NF}')
        GCP_CLI_ENABLED=1
        messagePrint "checking for gcloud CLI utility" "installed - ${GCLOUD_VERSION}"
      else
        echo ""
        echo "ERROR: The gcloud utility does not seam to be correct"
        echo "       please install gcloud from https://cloud.google.com/sdk/install"; exit 1
      fi
    else
      messagePrint "checking for gcloud CLI utility" "not installed"
      echo ""
      echo "ERROR: gcloud utility is not installed. please install terraform from"
      echo "       https://cloud.google.com/sdk/install"; exit 1
    fi

    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility (needed for AWS Route53)" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    # --- CHECK FOR AWS CLI ---
    AZCLI=$(which az)
    if [ "${AZCLI}" != "" ]; then
      $AZCLI -v >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AZ_VERSION=$($AZCLI -v 2>/dev/null | egrep "^azure-cli" | awk '{ print $2 }'); ret=$?
        AZURE_CLI_ENABLED=1
        messagePrint "checking for Azure CLI utility (az)" "installed - ${AZ_VERSION}"
      else
        echo ""
        echo "ERROR: the $cloud CLI $(which az) does not seam to be correct"
        echo "       please install it from https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest"; exit 1
      fi
    else
      messagePrint "checking for $cloud CLI utility" "no installed"
    fi
    # --- CHECK FOR AWS CLI ---
    AWSCLI=$(which aws)
    if [ "${AWSCLI}" != "" ]; then
      $AWSCLI --version >/dev/null 2>&1; ret=$?
      if [ ${ret} -eq 0 ]; then
        AWS_VERSION=$($AWSCLI --version 2>/dev/null | awk -F'/' '{ print $2 }' | awk '{ print $1}')
        AWS_CLI_ENABLED=1
        messagePrint "checking for AWS CLI utility (needed for AWS Route53)" "installed - ${AWS_VERSION}"
      else
        echo ""
        echo "ERROR: the AWS cli utility does not seam to be correct, please reinstall it from:"
        echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
      fi
    else
      messagePrint "checking for AWS CLI utility" "not installed"
      echo "ERROR: the AWS cli utility is not installed, please install it from:"
      echo "       https://docs.aws.amazon.com/cli/latest/userguide/cli-chap-install.html"; exit 1
    fi
  fi
}

checkCloudAccess() {
  missing_variables=0

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "GCP" ]; then
    #if [ "${GCP_SERVICE_ACCOUNT}" == "" -o "${GCP_REGION}" == "" -o "${GCP_PROJECT}" == "" ]; then
    if [ "${GCP_REGION}" == "" -o "${GCP_PROJECT}" == "" ]; then
      missing_variables=1
      echo ""
      echo "  4MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      #if [ "${GCP_SERVICE_ACCOUNT}" == "" ]; then
      #  echo "  GCP_SERVICE_ACCOUNT           (required) GCP Service Account"
      #fi

      if [ "${GCP_PROJECT}" == "" ]; then
        echo "  GCP_PROJECT                   (required) GCP Project"
        echo "                                  => gcloud projects list | sed '1d' | awk '{ print \$1 }'"
      fi

      if [ "${GCP_REGION}" == "" ]; then
        echo "  GCP_REGION                    (required) Choose the GCP Region where your installation should run"
        echo "                                  => gcloud compute zones list | sed '1d' | awk '{ print $2 }' | sort -u"
        echo "                                     europe-west1, us-east1, europe-west4  etc."
      fi
    else
      echo "GCP Access Credentials"
      #messagePrint " - GCP Service Account"          "$GCP_SERVICE_ACCOUNT"
      messagePrint " - GCP Project"                  "$GCP_PROJECT"
      messagePrint " - GCP Region"                   "$GCP_REGION"
    fi
  fi

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "AWS" ]; then
    if [ "${AWS_ACCESS_KEY}" == "" -o "${AWS_SECRET_KEY}" == "" -o \
         "${AWS_REGION}" == "" ]; then

      missing_variables=1
      echo ""
      echo "  5MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${AWS_ACCESS_KEY}" == "" ]; then
        echo "  AWS_ACCESS_KEY                  (required) AWS Acess Key"
      fi

      if [ "${AWS_SECRET_KEY}" == "" ]; then
        echo "  AWS_SECRET_KEY                  (required) AWS Secret Key"
      fi

      if [ "${AWS_REGION}" == "" ]; then
        echo "  AWS_REGION                    (required) Choose the AWS Region where your installation should run"
        echo "                                  => aws ec2 --region=eu-west-3 describe-regions --output text | awk '{ print $NF }'"
        echo "                                     eu-north-1, eu-west-3, eu-central-1 etc."
      fi
    else
      messageTitle "Azure Access Credentials"
      messagePrint " - AWS AccwssKey"                $(maskPassword "$AWS_ACCESS_KEY")
      messagePrint " - AWS SecretKey"                $(maskPassword "$AWS_SECRET_KEY")
      messagePrint " - AWS Region"                   "$AWS_REGION"
    fi
  fi

  if [ "${TDH_DEPLOYMENT_ENV_NAME}" == "Azure" ]; then
    if [ "${AZURE_SUBSCRIPTION_ID}" == "" -o "${AZURE_TENANT_ID}" == "" -o \
         "${AZURE_CLIENT_ID}" == "" -o "${AZURE_CLIENT_SECRET}" == "" -o "${AZURE_REGION}" == "" ]; then

      missing_variables=1
      echo ""
      echo "  1MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
      echo "  --------------------------------------------------------------------------------------------------------------"

      if [ "${AZURE_SUBSCRIPTION_ID}" == "" ]; then
        echo "  AZURE_SUBSCRIPTION_ID           (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi

      if [ "${AZURE_TENANT_ID}" == "" ]; then
        echo "  AZURE_TENANT_ID                 (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
      fi

      if [ "${AZURE_CLIENT_ID}" == "" ]; then
        echo "  AZURE_CLIENT_ID                 (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
        echo "                                  => az ad sp create-for-rbac --name \"TanzuDemoHub\" ## appId"
      fi

      if [ "${AZURE_CLIENT_SECRET}" == "" ]; then
        echo "  AZURE_CLIENT_SECRET             (required) has the format <xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx>"
        echo "                                  => az ad sp create-for-rbac --name \"TanzuDemoHub\" ## password"
      fi

      if [ "${AZURE_REGION}" == "" ]; then
        echo "  AZURE_REGION                    (required) Choose the Azure Region where your installation should run"
        echo "                                  => az account list-locations -o table | awk '{ print $NF }'"
        echo "                                     westeurope, northeurope, switzerlandnorth etc."
      fi
    else
      messageTitle "Azure Access Credentials"
      messagePrint " - Azure SubscriptionId"         $(maskPassword "$AZURE_SUBSCRIPTION_ID")
      messagePrint " - Azure TennantId"              $(maskPassword "$AZURE_TENANT_ID")
      messagePrint " - Azure ClientId"               $(maskPassword "$AZURE_CLIENT_ID")
      messagePrint " - Azure Client Secret"          $(maskPassword "$AZURE_CLIENT_SECRET")
      messagePrint " - Azure Region"                 "$AZURE_REGION"
    fi
  fi

  if [ ${missing_variables} -eq 1 ]; then
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  IMPORTANT: Please set the missing environment variables either in your shell or in the pcfconfig"
    echo "             configuration file ~/.pcfconfig and set all variables with the 'export' notation"
    echo "             ie. => export AZURE_PKS_TLS_CERTIFICATE=/home/demouser/certs/cert.pem"
    echo "  --------------------------------------------------------------------------------------------------------------"
    exit 1
  fi
}

checkTDHAccess() {
  missing_variables=0

  if [ "${PCF_PIVNET_TOKEN}" == "" -o "${AWS_HOSTED_DNS_DOMAIN}" == "" ]; then
    missing_variables=1
    echo ""
    echo "  2MISSING ENVIRONMENT-VARIABES    DESCRIPTION        "
    echo "  --------------------------------------------------------------------------------------------------------------"

    if [ "${PCF_PIVNET_TOKEN}" == "" ]; then
      echo "  PCF_PIVNET_TOKEN                (required) PIVNET Access Token to download software. Get a UAA API TOKEN from"
      echo "                                  => https://network.pivotal.io/users/dashboard/edit-profile"
    fi

    if [ "${AWS_ACCESS_KEY}" == "" ]; then
      echo "  AWS_ACCESS_KEY                  (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    if [ "${AWS_SECRET_KEY}" == "" ]; then
      echo "  AWS_SECRET_KEY                  (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    if [ "${AWS_HOSTED_DNS_DOMAIN}" == "" ]; then
      echo "  AWS_HOSTED_DNS_DOMAIN           (required) A DNS Domain managed by AWS Route 53 ie. yourdomain.com with a"
      echo "                                  valid DNS Zone. => https://console.aws.amazon.com/route53"
    fi

    #if [ "${AWS_HOSTED_ZONE_ID}" == "" ]; then
    #  echo "  AWS_HOSTED_ZONE_ID              (required) An AWS Route 53 Token is required to add/update DNS records"
    #  echo "                                  => https://console.aws.amazon.com/route53 -> hosted Zones -> Zone ID"
    #fi
  else
    messageTitle "Supporting services access (Pivotal Network, AWS Route53)"
    messagePrint " - Pivotal Network Token"           "$PCF_PIVNET_TOKEN"
    messagePrint " - AWS Route53 Hosted DNS Domain"   "$AWS_HOSTED_DNS_DOMAIN"

    # --- VERIFY PIVNET ACCESS ---
    pivnetAPI $PCF_PIVNET_TOKEN
    if [ $? -ne 0 ]; then
      write_line
      echo "ERROR: Pivnet Token: $PCF_PIVNET_TOKEN does not seam to be valit. Please greate a new one by"
      echo "       login to http://network.pivotal.io => Your login Name => Edit Profile => UAA API TOKEN"
      exit 1
    fi

    # --- CHECK IF AWS CLI IS CONFIGURED ---
    if [ ! -d ~/.aws -o -d ~/.aws/credentials ]; then
      echo "ERROR: AWS CLI is not configured yet, please run aws configure"
      echo "       => aws configure"
      exit 1
    fi

    export AWS_HOSTED_ZONE_ID=$(aws route53 list-hosted-zones --query "HostedZones[?starts_with(to_string(Name), '${AWS_HOSTED_DNS_DOMAIN}.')]" | \
                        jq -r '.[].Id' | awk -F '/' '{ print $NF }')
    if [ $? -ne 0 -o "${AWS_HOSTED_ZONE_ID}" == "" ]; then
      echo "ERROR: failed to get domain information for ($AWS_HOSTED_DNS_DOMAIN)"
      echo "       => aws route53 list-hosted-zones --query \"HostedZones[?starts_with(to_string(Name), '${AWS_HOSTED_DNS_DOMAIN}.')]\""
      exit 1
    else
      messagePrint " - AWS Route53 ZoneID"              "$AWS_HOSTED_ZONE_ID"
    fi

    pslug="pivotal-container-service"; pver="1.5"
    pslug="elastic-runtime"; pver="2.6.6"
    pslug="elastic-runtime"; pver="467928"
  fi

  if [ ${missing_variables} -eq 1 ]; then
    echo "  --------------------------------------------------------------------------------------------------------------"
    echo "  IMPORTANT: Please set the missing environment variables either in your shell or in the pcfconfig"
    echo "             configuration file ~/.pcfconfig and set all variables with the 'export' notation"
    echo "             ie. => export AZURE_PKS_TLS_CERTIFICATE=/home/demouser/certs/cert.pem"
    echo "  --------------------------------------------------------------------------------------------------------------"
    exit 1
  fi

} 

pivnetAPI() {
  REFRESH_TOKEN="$1"
  token=$(curl -X POST https://network.pivotal.io/api/v2/authentication/access_tokens \
               -d "{\"refresh_token\":\"$REFRESH_TOKEN\"}" 2>/dev/null | jq -r '.access_token')
  if [ "${token}" == "" -o "${token}" == "null" ]; then return 1; fi

  # --- LOGIN INTO PIVNET ---
  curl -X GET https://network.pivotal.io/api/v2/authentication -H "Authorization: Bearer $token"

  # --- PIVNET ACCESS TEST ---
  if [ "${2}" == "" ]; then
    return 0
  fi

  curl -H "Authorization: Bearer $token" -X $2 https://network.pivotal.io/api/v2/$3

  return 0
}

write_line() {
  messageTitle "----------------------------------------------------------------------------------------------------------------"
}

createENVfile() {
  dep="$1"
  envFile="$2"

  rm -f $env
  . ${TANZU_DEMO_HUB}/deployments/$dep

  cat ${TANZU_DEMO_HUB}/deployments/$dep | sed -e '/^$/d' -e '/^#/d' -e 's/#.*$//g' > $envFile

  echo "PCF_DEPLOYMENT_DEBUG=$PCF_DEPLOYMENT_DEBUG"                              >> $envFile
  echo "AWS_HOSTED_ZONE_ID=$AWS_HOSTED_ZONE_ID"                                  >> $envFile
  echo "AWS_HOSTED_DNS_DOMAIN=$AWS_HOSTED_DNS_DOMAIN"                            >> $envFile
  echo "PCF_PIVNET_TOKEN=$PCF_PIVNET_TOKEN"                                      >> $envFile

  echo "PCF_TILE_PKS_ADMIN_USER=$PCF_TILE_PKS_ADMIN_USER"                        >> $envFile
  echo "PCF_TILE_PKS_ADMIN_PASS=$PCF_TILE_PKS_ADMIN_PASS"                        >> $envFile
  echo "PCF_TILE_PKS_ADMIN_EMAIL=$PCF_TILE_PKS_ADMIN_EMAIL"                      >> $envFile
  echo "PCF_TILE_PAS_ADMIN_USER=$PCF_TILE_PAS_ADMIN_USER"                        >> $envFile
  echo "PCF_TILE_PAS_ADMIN_PASS=$PCF_TILE_PAS_ADMIN_PASS"                        >> $envFile
  echo "PCF_TILE_PAS_ADMIN_EMAIL=$PCF_TILE_PAS_ADMIN_EMAIL"                      >> $envFile

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "GCP" ]; then
    #echo "GCP_SERVICE_ACCOUNT=/tmp/$(basename $GCP_SERVICE_ACCOUNT)"             >> $envFile
    echo "GCP_REGION=\"$GCP_REGION\""                                            >> $envFile
    echo "GCP_PROJECT=\"$GCP_PROJECT\""                                          >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then
      if [ "${GCP_PKS_TLS_CERTIFICATE}" != "" -a "${GCP_PKS_TLS_FULLCHAIN}" != "" -a \
           "${GCP_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$GCP_PKS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$GCP_PKS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$GCP_PKS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${GCP_PAS_TLS_CERTIFICATE}" != "" -a "${GCP_PAS_TLS_FULLCHAIN}" != "" -a \
           "${GCP_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$GCP_PAS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$GCP_PAS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$GCP_PAS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_HARBOR_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_HARBOR_ADMIN_PASS=\"$PCF_TILE_HARBOR_ADMIN_PASS\"" >> $envFile
    fi
    if [ "${PCF_TILE_PBS_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_PBS_DEPLOY=\"$PCF_TILE_PBS_DEPLOY\""               >> $envFile
      echo "PCF_TILE_PBS_NAME=\"$PCF_TILE_PBS_NAME\""                   >> $envFile
      echo "PCF_TILE_PBS_SLUG=\"$PCF_TILE_PBS_SLUG\""                   >> $envFile
      echo "PCF_TILE_PBS_VERSION=\"$PCF_TILE_PBS_VERSION\""             >> $envFile
      echo "PCF_TILE_PBS_ADMIN_USER=\"$PCF_TILE_PBS_ADMIN_USER\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_PASS=\"$PCF_TILE_PBS_ADMIN_PASS\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_EMAIL=\"$PCF_TILE_PBS_ADMIN_EMAIL\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_REPO=\"$PCF_TILE_PBS_DOCKER_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_USER=\"$PCF_TILE_PBS_DOCKER_USER\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_PASS=\"$PCF_TILE_PBS_DOCKER_PASS\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_REPO=\"$PCF_TILE_PBS_GITHUB_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_USER=\"$PCF_TILE_PBS_GITHUB_USER\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_PASS=\"$PCF_TILE_PBS_GITHUB_PASS\""     >> $envFile
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
    echo "AWS_ACCESS_KEY=\"$AWS_ACCESS_KEY\""                                    >> $envFile
    echo "AWS_SECRET_KEY=\"$AWS_SECRET_KEY\""                                    >> $envFile
    echo "AWS_REGION=\"$AWS_REGION\""                                            >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then
      if [ "${AWS_PKS_TLS_CERTIFICATE}" != "" -a "${AWS_PKS_TLS_FULLCHAIN}" != "" -a \
           "${AWS_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AWS_PKS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$AWS_PKS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AWS_PKS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${AWS_PAS_TLS_CERTIFICATE}" != "" -a "${AWS_PAS_TLS_FULLCHAIN}" -o \
           "${AWS_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AWS_PAS_TLS_CERTIFICATE\""              >> $envFile
        echo "TLS_FULLCHAIN=\"$AWS_PAS_TLS_FULLCHAIN\""                  >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AWS_PAS_TLS_PRIVATE_KEY\""              >> $envFile
      fi
    fi

    if [ "${PCF_TILE_HARBOR_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_HARBOR_ADMIN_PASS=\"$PCF_TILE_HARBOR_ADMIN_PASS\"" >> $envFile
    fi

    if [ "${PCF_TILE_PBS_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_PBS_DEPLOY=\"$PCF_TILE_PBS_DEPLOY\""               >> $envFile
      echo "PCF_TILE_PBS_NAME=\"$PCF_TILE_PBS_NAME\""                   >> $envFile
      echo "PCF_TILE_PBS_SLUG=\"$PCF_TILE_PBS_SLUG\""                   >> $envFile
      echo "PCF_TILE_PBS_VERSION=\"$PCF_TILE_PBS_VERSION\""             >> $envFile
      echo "PCF_TILE_PBS_ADMIN_USER=\"$PCF_TILE_PBS_ADMIN_USER\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_PASS=\"$PCF_TILE_PBS_ADMIN_PASS\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_EMAIL=\"$PCF_TILE_PBS_ADMIN_EMAIL\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_REPO=\"$PCF_TILE_PBS_DOCKER_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_USER=\"$PCF_TILE_PBS_DOCKER_USER\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_PASS=\"$PCF_TILE_PBS_DOCKER_PASS\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_REPO=\"$PCF_TILE_PBS_GITHUB_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_USER=\"$PCF_TILE_PBS_GITHUB_USER\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_PASS=\"$PCF_TILE_PBS_GITHUB_PASS\""     >> $envFile
    fi
  fi

  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" ]; then
    echo "AZURE_SUBSCRIPTION_ID=\"$AZURE_SUBSCRIPTION_ID\""                      >> $envFile
    echo "AZURE_TENANT_ID=\"$AZURE_TENANT_ID\""                                  >> $envFile
    echo "AZURE_CLIENT_ID=\"$AZURE_CLIENT_ID\""                                  >> $envFile
    echo "AZURE_CLIENT_SECRET=\"$AZURE_CLIENT_SECRET\""                          >> $envFile
    echo "AZURE_REGION=\"$AZURE_REGION\""                                        >> $envFile

    echo "PCF_TERRAFORMS_TEMPLATE_BUNDLE=\"$PCF_TERRAFORMS_TEMPLATE_BUNDLE\""    >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_NAME=\"$PCF_TERRAFORMS_TEMPLATE_NAME\""        >> $envFile
    echo "PCF_TERRAFORMS_TEMPLATE_VERSION=\"$PCF_TERRAFORMS_TEMPLATE_VERSION\""  >> $envFile

    if [ "${PCF_TILE_PKS_DEPLOY}" == "true" ]; then
      if [ "${AZURE_PKS_TLS_CERTIFICATE}" != "" -a "${AZURE_PKS_TLS_FULLCHAIN}" -o \
           "${AZURE_PKS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AZURE_PKS_TLS_CERTIFICATE\""           >> $envFile
        echo "TLS_FULLCHAIN=\"$AZURE_PKS_TLS_FULLCHAIN\""               >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AZURE_PKS_TLS_PRIVATE_KEY\""           >> $envFile
      fi
    fi

    if [ "${PCF_TILE_PAS_DEPLOY}" == "true" ]; then
      if [ "${AZURE_PAS_TLS_CERTIFICATE}" != "" -a "${AZURE_PAS_TLS_FULLCHAIN}" -o \
           "${AZURE_PAS_TLS_PRIVATE_KEY}" != "" ]; then

        echo "TLS_CERTIFICATE=\"$AZURE_PAS_TLS_CERTIFICATE\""           >> $envFile
        echo "TLS_FULLCHAIN=\"$AZURE_PAS_TLS_FULLCHAIN\""               >> $envFile
        echo "TLS_PRIVATE_KEY=\"$AZURE_PAS_TLS_PRIVATE_KEY\""           >> $envFile
      fi
    fi

    if [ "${PCF_TILE_HARBOR_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_HARBOR_ADMIN_PASS=\"$PCF_TILE_HARBOR_ADMIN_PASS\"" >> $envFile
    fi

    if [ "${PCF_TILE_PBS_DEPLOY}" == "true" ]; then
      echo "PCF_TILE_PBS_DEPLOY=\"$PCF_TILE_PBS_DEPLOY\""               >> $envFile
      echo "PCF_TILE_PBS_NAME=\"$PCF_TILE_PBS_NAME\""                   >> $envFile
      echo "PCF_TILE_PBS_SLUG=\"$PCF_TILE_PBS_SLUG\""                   >> $envFile
      echo "PCF_TILE_PBS_VERSION=\"$PCF_TILE_PBS_VERSION\""             >> $envFile
      echo "PCF_TILE_PBS_ADMIN_USER=\"$PCF_TILE_PBS_ADMIN_USER\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_PASS=\"$PCF_TILE_PBS_ADMIN_PASS\""       >> $envFile
      echo "PCF_TILE_PBS_ADMIN_EMAIL=\"$PCF_TILE_PBS_ADMIN_EMAIL\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_REPO=\"$PCF_TILE_PBS_DOCKER_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_USER=\"$PCF_TILE_PBS_DOCKER_USER\""     >> $envFile
      echo "PCF_TILE_PBS_DOCKER_PASS=\"$PCF_TILE_PBS_DOCKER_PASS\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_REPO=\"$PCF_TILE_PBS_GITHUB_REPO\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_USER=\"$PCF_TILE_PBS_GITHUB_USER\""     >> $envFile
      echo "PCF_TILE_PBS_GITHUB_PASS=\"$PCF_TILE_PBS_GITHUB_PASS\""     >> $envFile
    fi
  fi
}

configureJumpHost() {
  messagePrint "Configure Jump Server" "$SSH_HOST"

  # --- WAIT UNTIL SSH DEAMON IS READY NO JUMPHOST ----
  ret=1
  while [ $ret -ne 0 ]; do
    $SSH_COMMAND -n id > /dev/null 2>&1; ret=$?
    [ $ret -ne 0 ] && sleep 10
  done

  GITTDH="https://github.com/pivotal-sadubois/tanzu-demo-hub.git"
  TDHHOME="${SSH_HOME}/tanzu-demo-hub"

  messagePrint " - Verify SSH Access" "success"
  messagePrint " - Update GIT repo"   "$GITTDH"

  $SSH_COMMAND -n "[ ! -d /home/ubuntu/tanzu-demo-hub ] && git clone $GITTDH > /dev/null 2>&1"
  $SSH_COMMAND -n "[ -d /home/ubuntu/tanzu-demo-hub ] && cd $SSH_HOME/tanzu-demo-hub; git pull > /dev/null 2>&1"

  # --- HOSTNAME ---
#  if [ "${TDH_DEPLOYMENT_CLOUD}" == "Azure" -o "${TDH_DEPLOYMENT_CLOUD}" == "AWS" ]; then
#    $SSH_COMMAND -n "sudo hostname $JUMP_HOST > /dev/null 2>&1"
#  fi

  # --- TEST FOR RUNNING REMOTE SCRIPT ---
  stt=$($SSH_COMMAND -n "[ -f /tmp/tanzu-demo-hub.pid ] && pgrep -F /tmp/tanzu-demo-hub.pid")
  stt=$($SSH_COMMAND -n "[ -f /jump_software_installed ] && echo true")
  if [ "${stt}" == "" ]; then
    messagePrint " - Install CLI Utilities"   "aws,az,gcp,bosh,pivnet,cf,om,jq"
    $SSH_COMMAND -n "[ -d $SSH_HOME/tanzu-demo-hub ] && chmod a+x ${TDHHOME}/scripts/InstallUtilities.sh && \
        sudo ${TDHHOME}/scripts/InstallUtilities.sh $PCF_PIVNET_TOKEN > /dev/null 2>&1"

    # --- COPY THE AWS DIRECTORY ---
    $SCP_COMMAND -r ~/.aws ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
    $SCP_COMMAND -r ~/.azure ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
    $SCP_COMMAND -r ~/.tanzu-demo-hub ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
    $SCP_COMMAND -r ~/.tanzu-demo-hub.cfg ${SSH_USER}@${SSH_HOST}:$SSH_HOME > /dev/null 2>&1
  fi

  # --- COPY SOFTWARE ---
  stt=$($SSH_COMMAND -n "[ -d /home/ubuntu/tanzu-demo-hub/software ] && echo true")
  if [ "${stt}" == "" ]; then
    # --- COPY THE AWS DIRECTORY ---
    $SCP_COMMAND -r ${TDHPATH}/software ${SSH_USER}@${SSH_HOST}:${SSH_HOME}/tanzu-demo-hub/ > /dev/null 2>&1
  fi

  # --- INSTALL TKG UTILITES ---
  stt=$($SSH_COMMAND -n "[ -f /tkg_software_installed ] && echo true")
  if [ "${stt}" == "" ]; then
    messagePrint " - Install TKG Utilities"   "tkg, ytt, kapp, kbld, kubectl, kind"
    $SSH_COMMAND -n "[ -d $SSH_HOME/tanzu-demo-hub ] && chmod a+x ${TDHHOME}/scripts/InstallTKGutilities.sh && \
        sudo ${TDHHOME}/scripts/InstallTKGutilities.sh \"$SSH_HOME/tanzu-demo-hub\" > /dev/null 2>&1"
  fi

}

route53createHostedZone() {
  zone=$1

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${zone} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$zone.\")).Id")
  if [ "${ZONE_ID}" != "" ]; then
    route53deleteHostedZone $ZONE_ID
  fi

  aws route53 create-hosted-zone --name $zone --caller-reference "$(date)" \
       --hosted-zone-config Comment="Managed by pcfconfig" > /dev/null 2>&1
  if [ $? -ne 0 ]; then
      echo "ERROR: failed to create AWS Route53 zone $ZONE_ID"
      echo "       => aws route53 create-hosted-zone --name $zone --caller-reference \"$(date)\" \\"
      echo "          --hosted-zone-config Comment=\"command-line version\""
      exit 1
  fi

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${zone} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$zone.\")).Id")
  NAME_SERVERS=$(aws route53 get-hosted-zone --id $ZONE_ID | jq -r '.DelegationSet.NameServers[]')

  # --- CREATE ZONE ---
  route53setNSrecord $zone "$AWS_HOSTED_DNS_DOMAIN" "$NAME_SERVERS"
}

route53setNSrecord () {
  hnm=$1; dom=$2; dns="$3"

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$dom.\")).Id")
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
  if [ "${ZONE_ID}" == "" ]; then
    echo "ERROR: ZoneID for domain $dom can not be optained, please veriofy manually"
    echo "       aws route53 list-hosted-zones-by-name --dns-name ${dom}"
    exit 1
  fi

  DNS1=$(echo $dns | awk '{ print $1 }')
  DNS2=$(echo $dns | awk '{ print $2 }')
  DNS3=$(echo $dns | awk '{ print $3 }')
  DNS4=$(echo $dns | awk '{ print $4 }')

  TMPROUTE53=/tmp/$$_tmp_route53.json
  echo "{"                                                   >  $TMPROUTE53
  echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
  echo "  \"Changes\": [{"                                   >> $TMPROUTE53
  echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
  echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
  echo "    \"Name\": \"${hnm}\","                           >> $TMPROUTE53
  echo "    \"Type\": \"NS\","                               >> $TMPROUTE53
  echo "    \"TTL\": 300,"                                   >> $TMPROUTE53
  echo "    \"ResourceRecords\": [ "                         >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS1}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS2}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS3}\" },"                   >> $TMPROUTE53
  echo "      { \"Value\": \"${DNS4}\" }"                    >> $TMPROUTE53
  echo "    ]"                                               >> $TMPROUTE53
  echo "}}]"                                                 >> $TMPROUTE53
  echo "}"                                                   >> $TMPROUTE53

  aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
      --change-batch file://${TMPROUTE53} > /dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to set DNS for $hnm"
    echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
    echo "              --change-batch file://${TMPROUTE53}"
    cat /tmp/$$_zone_record
    exit 1
  fi
}

route53deleteHostedZone() {
  ZONE_ID=$1
  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID | jq -c '.ResourceRecordSets[]' | \
  while read -r resourcerecordset; do
    read -r name type <<<$(echo $(jq -r '.Name,.Type' <<<"$resourcerecordset"))

     if [ $type != "NS" -a $type != "SOA" ]; then
        aws route53 change-resource-record-sets \
          --hosted-zone-id $ZONE_ID \
          --change-batch '{"Changes":[{"Action":"DELETE","ResourceRecordSet":
          '"$resourcerecordset"'
        }]}' \
        --output text --query 'ChangeInfo.Id' >/dev/null 2>&1
     fi
  done

  aws route53 delete-hosted-zone --id $ZONE_ID >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    echo "ERROR: failed to delete AWS Route53 zone $ZONE_ID"
    echo "       => aws route53 delete-hosted-zone --id $ZONE_ID"
    #exit 1
  fi
}

checkKeyPairs() {
  SSH_KEY_NAME=vmware-cloud-tmc
  SSH_KEY_FILE=~/.tanzu-demo-hub/KeyPair-${SSH_KEY_NAME}-${AWS_REGION}.pem

  #"KeyFingerprint": "a8:c4:01:2b:12:7e:0d:8f:56:8c:38:80:cf:8b:6d:53:13:9c:28:cd",
  #aws ec2 --region=eu-central-1 create-key-pair --dry-run --key-name sacha
  #/tmp/key.pem

  if [ ! -d ~/.tanzu-demo-hub ] ; then mkdir ~/.tanzu-demo-hub; fi

  # --- VERIFY KEY-PAIR ---
  key=$(aws ec2 --region=$AWS_REGION describe-key-pairs | \
        jq -r --arg key "$SSH_KEY_NAME" '.KeyPairs[] | select(.KeyName == $key).KeyFingerprint')

  # --- CREATE ONE IF IT DOES NOT EXIST ---
  if [ "${key}" == "" ]; then
    aws ec2 --region=$AWS_REGION create-key-pair --key-name vmware-cloud-tmc | \
       jq -r '.KeyMaterial' > $SSH_KEY_FILE
    chmod 600 $SSH_KEY_FILE
  fi

  if [ -f "${SSH_KEY_FILE}" ]; then
    kfp=$(openssl pkcs8 -in $SSH_KEY_FILE -inform PEM -outform DER -topk8 -nocrypt | openssl sha1 -c)

    if [ "${key}" != "${kfp}" ]; then
      echo "ERROR: Fingerprint of AWS SSH Key-pair ($SSH_KEY_NAME) and the local PEM file: "
      echo "       $SSH_KEY_FILE are not the same"
      exit
    fi
  fi
}

maskPassword() {
  echo "$1" | sed 's/[^-]/X/g'
}

route53getIPaddress() {
  env=$1
  dom=$2
  hst="jump-${env}.${dom}."
  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r ".HostedZones[] | select(.Name | \
            scan(\"^$dom.\")).Id")
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')

  aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID_STR --query "ResourceRecordSets[?Name == '${hst}']" | \
  jq -r '.[].ResourceRecords[].Value'
}

#route53setDNSrecord "$pip" "$JUMP_HOST" "$AWS_HOSTED_DNS_DOMAIN"
route53setDNSrecord() {
  ipa=$1; hnm=$2; dom=$3

  ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${dom} | jq -r '.HostedZones[0].Id')
  ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
  if [ "${ZONE_ID}" == "" ]; then
    echo "ERROR: ZoneID for domain $dom can not be optained, please veriofy manually"
    echo "       aws route53 list-hosted-zones-by-name --dns-name ${dom}"
    exit 1
  fi

cat << EOF | sed -e "s/FQHN/$hnm/g" -e "s/IPADDR/$ipa/g" > /tmp/$$_zone_record
{
            "Comment": "CREATE/DELETE/UPSERT a record ",
            "Changes": [{
            "Action": "UPSERT",
                        "ResourceRecordSet": {
                                    "Name": "FQHN",
                                    "Type": "A",
                                    "TTL": 300,
                                 "ResourceRecords": [{ "Value": "IPADDR"}]
}}]
}
EOF

   aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record > /dev/null 2>&1
   if [ $? -ne 0 ]; then
     echo "ERROR: failed to set DNS for $hnm"
     echo "       => aws route53 change-resource-record-sets --hosted-zone-id "${ZONE_ID}" --change-batch file:///tmp/$$_zone_record"
     cat /tmp/$$_zone_record
     exit 1
   fi
}

createCluster() {
  messageTitle "Creating TKG Managment Cluster"
  messagePrint " - Cluster Name"             "$TDH_TKGMC_NAME"
  messagePrint " - Configuration File"       "${TDHPATH}/config/${TDH_TKGMC_CONFIG}"

  stt=$(tkg get mc --name $TDH_TKGMC_NAME -o json | jq -r '.[].status')
  if [ "${stt}" != "Success" ]; then
    echo "----------------------------------------------------------------------------------------------------------------"
    echo "tkg init -q -i azure -p dev --ceip-participation true --cni antrea -v 0 \\"
    echo "         --name $TDH_TKGMC_NAME --config ${TDHPATH}/config/${TDH_TKGMC_CONFIG}"
    echo "----------------------------------------------------------------------------------------------------------------"
    time tkg init -i azure -p dev --ceip-participation true --cni antrea -v 0 --name $TDH_TKGMC_NAME --config ${TDHPATH}/config/${TDH_TKGMC_CONFIG}
    echo "----------------------------------------------------------------------------------------------------------------"
  fi
}

setTKGclusterDNS() {
  TKG_CLUSTER="$1"
  TKG_IPADRESS="$2"
  DNS_PREFIX="$TDH_TKGMC_ENVNAME"
  DNS_SUFFIX="$AWS_HOSTED_DNS_DOMAIN"

  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "AWS" ]; then
    AWS_ID=$(echo $DNSLB | awk -F '-' '{ print $1 }')
    AWS_LB="k8s-master-$TKG_CLUSTER"
    AWS_SG=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names $AWS_ID | \
             jq -r '.LoadBalancerDescriptions[].SecurityGroups[]')
    AWS_VP=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names $AWS_ID | \
             jq -r '.LoadBalancerDescriptions[].VPCId')
  
    cnt=$(echo "${AWS_SG}" | egrep -c "$AWS_SG_NEW")
    if [ $cnt -eq 0 ]; then
      a=1
    fi
  fi
  
  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "GCP" ]; then
    DNS_NAME="*.apps-${TKG_CLUSTER}"
    messagePrint "- Create DNS Entry for:" "*.apps-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"
  
    cnt=$(gcloud dns record-sets list -z ${DNS_PREFIX}-zone --name "${DNS_NAME}.${DNS_PREFIX}.${DNS_SUFFIX}." \
            --type=A 2> /dev/null | grep -v "^NAME" | wc -l | sed 's/ //g')
    if [ ${cnt} -eq 0 ]; then
      messagePrint " - Creating DNS Entry in (${DNS_PREFIX}-zone)" "${DNS_NAME}"
      gcloud dns record-sets transaction abort -z ${DNS_PREFIX}-zone > /dev/null 2>&1
      gcloud dns record-sets transaction start -z ${DNS_PREFIX}-zone > /dev/null 2>&1
      gcloud dns record-sets transaction add "$DNSLB" --name "${DNS_NAME}.${DNS_PREFIX}.${DNS_SUFFIX}." \
         --type A -z ${DNS_PREFIX}-zone --ttl=300 > /dev/null 2>&1
      gcloud dns record-sets transaction execute -z ${DNS_PREFIX}-zone > /dev/null 2>&1; ret=$?
      if [ ${ret} -ne 0 ]; then
        echo "ERROR: Creating DNS record-sets for zone (${DNS_PREFIX}-zone)"
        echo "       => gcloud dns record-sets transaction execute -z ${DNS_PREFIX}-zone"
        exit 1
      fi
    fi
  fi
  
  if [ "${TDH_TKGMC_INFRASTRUCTURE}" == "Azure" ]; then
    DNS_NAME="*.apps-${TKG_CLUSTER}"
    messagePrint "- LoadBalancer PublicIP:" "$TKG_IPADRESS"
    messagePrint "- Create DNS Entry for:" "*.apps-${TKG_CLUSTER}.${DNS_PREFIX}.${DNS_SUFFIX}"

    ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
    DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
        jq -r '.LoadBalancerDescriptions[0].DNSName')
    DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
        jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')
    ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_PREFIX}.${DNS_SUFFIX} | jq -r '.HostedZones[0].Id')

    ALIAS=$(aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID \
            --query "ResourceRecordSets[?contains(Name, 'apps-${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}')].AliasTarget.DNSName" | \
            jq -r '.[]' | sed -e 's/dualstack\.//g' -e 's/\.$//g' )


echo "ZONE_ID_STR:$ZONE_ID_STR"
echo "DNSLB:$DNSLB"
echo "DNSLB_ZONEID:$DNSLB_ZONEID"
echo "ZONE_ID:$ZONE_ID"
echo "ALIAS:$ALIAS"

exit
  
echo "az network dns record-set a show -g $DNS_PREFIX -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME"
    az network dns record-set a show -g $DNS_PREFIX -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME > /dev/null 2>&1
    if [ $? -eq 0 ]; then
     ipa=$(az network dns record-set a show -g $DNS_PREFIX -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME | \
         jq -r '.arecords[].ipv4Address')
echo "IPA:$ipa"
      az network dns record-set a remove-record -g $DNS_PREFIX -z ${DNS_PREFIX}.${DNS_SUFFIX} \
         -n $DNS_NAME -a $ipa > /dev/null 2>&1
      if [ $? -ne 0 ]; then
        debugInfos $(($BITMASK_JMP+$BITMASK_OPS+$BITMASK_PXS+$BITMASK_K8S))
  
        echo "ERROR: failed to delete DNS record-set for $DNS_NAME"
        echo "       => az network dns record-set a remove-record -g $DNS_PREFIX \\"
        echo "          -n $DNS_NAME -a $ipa"
        exit 1
      fi
    fi

    az network dns record-set a add-record -g $DNS_PREFIX -z "${DNS_PREFIX}.${DNS_SUFFIX}" \
        -n "$DNS_NAME" --ipv4-address $DNSLB > /dev/null 2>&1
    if [ $? -ne 0 ]; then
      debugInfos $(($BITMASK_JMP+$BITMASK_OPS+$BITMASK_PXS+$BITMASK_K8S))
  
      echo "ERROR: failed to create DNS record-set for $DNS_NAME"
      echo "       => az network dns record-set a add-record -g $DNS_PREFIX \\"
      echo "          -z ${DNS_PREFIX}.${DNS_SUFFIX} -n $DNS_NAME --ipv4-address $DNSLB"
      exit 1
    fi
  fi

  if [ "${AWS_HOSTED_ZONE_ID}" != "" -a "${TDH_TKGMC_INFRASTRUCTURE}" == "AWS" ]; then
    ZONE_ID_STR=$(echo "${ZONE_ID}" | awk -F'/' '{ print $NF }')
    DNSLB=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
        jq -r '.LoadBalancerDescriptions[0].DNSName')
    DNSLB_ZONEID=$(aws elb --region $AWS_REGION describe-load-balancers --load-balancer-names "$AWS_ID" | \
        jq -r '.LoadBalancerDescriptions[0].CanonicalHostedZoneNameID')
    ZONE_ID=$(aws route53 list-hosted-zones-by-name --dns-name ${DNS_PREFIX}.${DNS_SUFFIX} | jq -r '.HostedZones[0].Id')
  
    ALIAS=$(aws route53 list-resource-record-sets --hosted-zone-id $ZONE_ID \
            --query "ResourceRecordSets[?contains(Name, 'apps-${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}')].AliasTarget.DNSName" | \
            jq -r '.[]' | sed -e 's/dualstack\.//g' -e 's/\.$//g' )
  
    if [ "${ALIAS}" != "$DNSLB" ]; then
      if [ "${ZONE_ID}" != "" ]; then
        echo "Create DNS Entry for *.apps-${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}:"
        ZONE="*.${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}"
        ZONE="*.apps-${cluster}.${DNS_PREFIX}.${DNS_SUFFIX}"
  
        TMPROUTE53=/tmp/$$_tmp_route53.json
        echo "{"                                                   >  $TMPROUTE53
        echo "  \"Comment\": \"CREATE/DELETE/UPSERT a record \","  >> $TMPROUTE53
        echo "  \"Changes\": [{"                                   >> $TMPROUTE53
        echo "  \"Action\": \"UPSERT\","                           >> $TMPROUTE53
        echo "  \"ResourceRecordSet\": {"                          >> $TMPROUTE53
        echo "    \"Name\": \"${ZONE}\","                          >> $TMPROUTE53
        echo "    \"Type\": \"A\","                                >> $TMPROUTE53
        echo "    \"AliasTarget\": {"                              >> $TMPROUTE53
        echo "      \"HostedZoneId\": \"${DNSLB_ZONEID}\","        >> $TMPROUTE53
        echo "      \"DNSName\": \"dualstack.${DNSLB}.\","         >> $TMPROUTE53
        echo "      \"EvaluateTargetHealth\": true"                >> $TMPROUTE53
        echo "    }"                                               >> $TMPROUTE53
        echo "}}]"                                                 >> $TMPROUTE53
        echo "}"                                                   >> $TMPROUTE53
  
        aws route53 change-resource-record-sets --hosted-zone-id $ZONE_ID \
            --change-batch file://${TMPROUTE53} > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "ERROR: failed to set DNS for $hnm"
          echo "       => aws route53 change-resource-record-sets --hosted-zone-id \"${ZONE_ID}\" \\"
          echo "              --change-batch file://${TMPROUTE53}"
          cat $TMPROUTE53
          exit 1
        fi
  
        rm -f $TMPROUTE53
      fi
    fi
  fi
}




